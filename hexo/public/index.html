<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Just do it">
<meta property="og:type" content="website">
<meta property="og:title" content="Glory Seeker">
<meta property="og:url" content="http://91yang.github.io/index.html">
<meta property="og:site_name" content="Glory Seeker">
<meta property="og:description" content="Just do it">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glory Seeker">
<meta name="twitter:description" content="Just do it">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://91yang.github.io/"/>

  <title> Glory Seeker </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Glory Seeker</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Make progress step by step everyday！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/17/Android小工具-方法计数统计DexCount-md/" itemprop="url">
                  Android小工具--方法计数统计DexCount.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-17T11:59:52+08:00" content="2016-06-17">
              2016-06-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android小工具–方法计数统计DexCount"><a href="#Android小工具–方法计数统计DexCount" class="headerlink" title="Android小工具–方法计数统计DexCount"></a>Android小工具–方法计数统计DexCount</h2><p>download:<a href="https://github.com/haiolv/tool-android" title="https://github.com/haiolv/tool-android" target="_blank" rel="external">Android小工具–方法计数统计DexCount 下载</a></p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>.
├── dex-method-counts.jar
├── tools.bat
├── app-debug_dexcount.txt


**dex-method-counts.jar**
获得方法的可执行jar包

**tools.bat**
tools.bat：获取某一apk方法数的bat批处理命令
</code></pre><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>将某一个需要查看方法数的apk拖入tools.bat上，然后就会在 当前目录生成 一个名为 “${apk名称}_dexcount.txt”文件，打开该文件，即可以看到具体的方法分布。</p>
<p>such as:</p>
<pre><code>Processing D:\UserProfiles\Haiolv\Downloads\app-debug.apk
Read in 64836 method IDs.
&lt;root&gt;: 64836
    &lt;default&gt;: 1
    adStats: 12
    android: 16841
        accessibilityservice: 6
        accounts: 5
        animation: 12
        app: 349
        bluetooth: 3
        content: 338
.....
</code></pre><p>如上，当将 app-debug.apk  拖入 tools.bat命令后，会在当前目录生成一个 名为 app-debug_dexcount.txt文件，打看我们可以看到该apk先总含有方法数为  64836，bomm..快超过 单个dex所允许的最大方法数了（65536），关于当apk方法数超过Short限制时，请查看 <a href="https://developer.android.com/studio/build/multidex.html" title="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="external">Configure Apps with Over 64K Methods</a></p>
<h3 id="批处理命令详解"><a href="#批处理命令详解" class="headerlink" title="批处理命令详解"></a>批处理命令详解</h3><pre><code>echo 拖入apk包
REM echo &quot;%~f1&quot;
REM echo &quot;%~dp0&quot;
REM echo %0
pushd %~dp0 

if exist ./dexcount.txt (
    rmdir /s /q ./dexcount.txt
)

REM echo %~n1
REM echo %~n1%_dexcount.txt
REM pause

java -jar ./dex-method-counts.jar &quot;%~f1&quot; &gt; ./%~n1%_dexcount.txt
popd
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/Android的事件处理机制/" itemprop="url">
                  Android的事件处理机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T18:59:48+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android的事件处理机制"><a href="#Android的事件处理机制" class="headerlink" title="Android的事件处理机制"></a>Android的事件处理机制</h2><p>Android的事件产生是从我们触摸屏幕开始，在经过Input子系统，最后达到我们的应用程序(或者经过WindowManagerService到达应用程序)。</p>
<p>而其中Input子系统在Java层对应着InputManagerService，其主要在native层，由InputReader读取EventHub的元数据，将这些数据加工成InputEvent，最后发到InputDispatcher，而InputDispatcher则负责将事件发到应用程序，Input子系统流程可以参见这篇文章 <a href="http://www.cnblogs.com/haiming/p/3318614.html" title="Android Framework——之Input子系统" target="_blank" rel="external">Android Framework——之Input子系统</a>。 和 <a href="http://blog.csdn.net/yclzh0522/article/details/6920522" title="http://blog.csdn.net/yclzh0522/article/details/6920522" target="_blank" rel="external">Android 事件捕捉和处理流程分析</a></p>
<p>对于应用层的时间流程，主要是下面的流程图所示：<br><img src="http://i.imgur.com/yugKXH4.png" alt="key-transfer"></p>
<p>其中最后一步就是我们经常说的View事件派发流程。而在流程图中，我们也看到，调了两次DecorView的方法，第一次是调用DecorView的dispatchTouchEvent，它的源码是:</p>
<pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    final Callback cb = getCallback();
    return cb != null &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev)
            : super.dispatchTouchEvent(ev);
}
</code></pre><p>调用了Callback的dispatchTouchEvent，那这个Callback是什么类型呢？</p>
<p>Callback就是Window.Callback，Activity实现了这个接口。在Activity的attach函数中，会调用window的setCallback，将Activity设置给Window。所以这里getCallback返回的就是Activity，最终会调用Activity的dispatchTouchEvent。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>在ACTION_DOWN事件处理的时候会调用onUserInteraction方法，然后调用Window（实际上是PhoneWindow)的superDispatchTouchEvent，如果Window的superDispatchTouchEvent消耗了事件，则直接返回，不会调用Activity的onTouchEvent方法。</p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}
</code></pre><p>而DecorView的superDispatchTouchEvent为:</p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}
</code></pre><p>最终还是调用DecorView的父类的dispatchTouchEvent，DecorView的父类是FrameLayout，它没实现该方法，最终会调用ViewGroup的dispatchTouchEvent方法。从这里开始就进入了view树的事件派发流程了。</p>
<p>此外，关于Android view树的事件派发流程，众说纷纭，给出一篇参考文章</p>
<p>Reference：<a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism/" title="http://www.infoq.com/cn/articles/android-event-delivery-mechanism/" target="_blank" rel="external">Android事件传递机制</a></p>
<p>然后，站在前人的肩膀上，接下俩文章主要做些验证。</p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h3><ul>
<li><p>Activity中dispatchTouchEvent在什么时候调用？</p>
</li>
<li><p>MotionEvent事件向下分发，是通过什么途径？通过dispatchKeyEvent的返回值？</p>
</li>
</ul>
<p>简单列举下工程</p>
<ul>
<li><p>Activity:</p>
<pre><code>// haio.com.event.MainActivity

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;Activity---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
//        boolean isDispatch = super.dispatchTouchEvent(event);
    boolean isDispatch = true;
    System.out.println(&quot;Activity---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}

@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    System.out.println(&quot;Activity---onKeyDown---DOWN&quot;);
    boolean isDown = super.onKeyDown(keyCode, event);
    System.out.println(&quot;Activity---onKeyDown---isDown =&quot; + isDown);
    return isDown;
}
</code></pre></li>
</ul>
<ul>
<li><p>HButton</p>
<p>  View(如 Button等) 涉及事件分发共涉及两个个事件</p>
<ul>
<li>dispatchTouchEvent</li>
<li><p>onTouchEvent</p>
<pre><code>//haio.com.event.widget.HButton
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HButton---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HButton---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HButton---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;HButton---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HButton---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HButton---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HButton---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = true;
    System.out.println(&quot;HButton---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre></li>
</ul>
</li>
<li><p>ViewGroup</p>
<p>  ViewGroup 涉及事件分发共涉及三个事件</p>
<ul>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li><p>onTouchEvent</p>
<pre><code>//haio.com.event.widget.HLinearLayout

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;HLinearLayout---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---UP&quot;);
            break;
        default:
            break;
    }

    boolean isIntercept = super.onInterceptTouchEvent(event);
    System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---isIntercept =&quot; + isIntercept);
    return isIntercept;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = true;
    System.out.println(&quot;HLinearLayout---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre></li>
</ul>
</li>
</ul>
<p>上述代码，细心的小伙伴们会发现，将MainActivity 中dispatchTouchEvent的返回值改为true,并屏蔽掉</p>
<pre><code>super.dispatchTouchEvent(event)
</code></pre><p>的调用，然后分别点击 Button 和 TextView的日志为：</p>
<pre><code>1.点击按钮：
06-14 17:41:58.639 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:41:58.639 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:41:58.689 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:41:58.689 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true

2.点击文本：
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:51:09.684 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:51:09.684 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:51:09.809 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:51:09.809 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
</code></pre><p>然后，我们在将MainActivity 中dispatchTouchEvent的返回值改为false，查看日志：</p>
<pre><code>06-14 17:54:23.509 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:54:23.509 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 17:54:23.524 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:54:23.524 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 17:54:23.579 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:54:23.579 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>从上面，我们得知，dispatchTouchEvent返回true 表明当前view/viewGroup负责处理该事件 ，false表明不负责处理该事件， 从日志打印结果中看出return true是不会有任何区别的。</p>
<p>那么，问题来了，Activity是通过调用上面来分发事件的呢？</p>
<p>我们将 MainActivity 中dispatchTouchEvent 改成如下，放开 super.dispatchTouchEvent(event) 的调用，并且返回true，表示 负责处理该事件。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }


    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = false;
    isDispatch = true;


    System.out.println(&quot;Activity---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre><p>日志打印为：</p>
<pre><code>06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouch---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouch---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.249 17504-17504/haio.com.event I/System.out: HButton---onClick---DOWN
</code></pre><p>事件分发了，这说明：</p>
<p>dispatchTouchEvent返回true 表明当前view/viewGroup负责处理该事件 false表明不负责处理该事件 在MainActivity中 如果你把return值改为false 打印结果和return true是不会有任何区别的 因为你根本就没有向下进行分发 MainActivity中分发是调用super.dispatchTouchEvent的。</p>
<p>注意，一个事件分发的完整过程：</p>
<pre><code>06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
</code></pre><p>后面三行打印，说明HButton、HLinearLayout、Activity都负责此事件，因此后续事件还会分发到HButton、HLinearLayout、Activity上。</p>
<h4 id="如果-子View不消耗事件，则回溯给Activity进行执行"><a href="#如果-子View不消耗事件，则回溯给Activity进行执行" class="headerlink" title="如果 子View不消耗事件，则回溯给Activity进行执行"></a>如果 子View不消耗事件，则回溯给Activity进行执行</h4><p>当你把HButton中的dispatchTouchEvent返回值改变为false的时候 说明没有调用View.onTouchEvent来消费事件,日志如下：</p>
<pre><code>06-14 18:09:10.934 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 18:09:10.959 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 18:09:11.014 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---MOVE
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>如上，当你把HButton中的dispatchTouchEvent返回值改变为false的时候 说明没有调用View.onTouchEvent来消费事件, 所以返回之后最终MainActivity的onTouchEvent还是会对Event进行处理, 假如某层dispatchTouchEvent返回值为false,那么后续的move up等等action就不会再被分发到当前层了.</p>
<p>注意，针对以上，下面日志反应一个事件的分发过程</p>
<pre><code>06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>打印说明HButton、HLinearLayout都不负责此事件（返回false），因此后续事件就不会分发到HButton、HLinearLayout上。</p>
<pre><code>06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/TCP_IP--三次握手-四次挥手/" itemprop="url">
                  TCP/IP--三次握手，四次挥手
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T10:23:00+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul>
<li>TCP为什么需要3次握手与4次挥手?</li>
<li>三次握手，四次挥手，为什么要用四次挥手，三次不行吗，当Client收到Server的ack后，Client还能接收来自Server的数据写入吗？</li>
</ul>
<p>或者说是怎么去解释“三次握手，四次挥手”？</p>
<p><img src="http://i.imgur.com/Cn6koqL.png" alt="tcp-head"></p>
<p>符号说明：</p>
<ul>
<li><p>seq:”sequance”序列号，Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
</li>
<li><p>ack:”acknowledge”确认号</p>
</li>
</ul>
<p>标志位，共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li><p>SYN:”synchronize”请求同步标志</p>
</li>
<li><p>ACK:”acknowledge”确认标志”，Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
</li>
<li><p>FIN：finish结束，”Finally”结束标志,释放一个连接。</p>
</li>
<li><p>RST:reset重置，重置连接。</p>
</li>
<li><p>URG:urgent紧急，紧急指针（urgent pointer）有效。</p>
</li>
<li><p>PUS:push传送，接收方应该尽快将这个报文交给应用层。</p>
</li>
</ul>
<p>注意：确认方Ack=发起方Req+1，两端配对。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://i.imgur.com/yrgs5LB.png" alt="tcp1"></p>
<p>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<p>reference:<a href="http://blog.csdn.net/whuslei/article/details/6667471/" title="http://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="external">http://blog.csdn.net/whuslei/article/details/6667471/</a></p>
<p><img src="http://i.imgur.com/uVngHhd.png" alt="tcp_draw"></p>
<ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server端收到TCP数据包之后，由标志位SYN=1知道Client请求简历TPC链接，Server端将标志位ACK和SYN都置为1（1表示有效），Act=J + 1，并随机产生一个Seq序列号，Seq=k，然后将该数据包发给Client端以确认并且同步此链接请求，Server端进入SYN_REVD状态.</p>
</li>
<li><p>第三次握手：CLient端收到确认后，首先检查ACK是否为1，且Ack是否为j+1，如果正确，则将ACK标志置为1，ack=k+1,并将该数据包发送给Server端，Server端检查Ack是否为k+1，ACK是否为1，如果正确，则表示链接建立成功Client和Server进入ESTABLISHED状态，完成三次握手之后，随之C和S就可以互通数据了。</p>
</li>
</ul>
<p>“<strong>三次握手</strong>”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p>
<p>这是因为：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。主要目的防止server端一直等待，浪费资源。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://i.imgur.com/oDESM4a.png" alt="tcp"></p>
<p>服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<p><img src="http://i.imgur.com/g4u6Tko.png" alt="tcp2"></p>
<blockquote>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
</blockquote>
<h3 id="整个过程流程图"><a href="#整个过程流程图" class="headerlink" title="整个过程流程图"></a>整个过程流程图</h3><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：<br><img src="http://i.imgur.com/4VD19KB.jpg" alt="tcp3"></p>
<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><p>【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<p>答：因为TCP链接是全双工模式，因此需要close链接时需要两方都需要单独进行链接释放。当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p>【问题3】为什么收到Server端的确认之后，Client还需要进行第三次“握手”呢？</p>
<p>答：在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！</p>
<p>并且，两次握手可能产生死锁。作为例子，考虑计算机server和client之间的通信，假定client给server发送一个连接请求分组，server收到了这个分组，并发送了确认应答分组。按照两次握手的协定，server认为连接已经成功地建立了，可以开始发送数据分组。可是，client在server的应答分组在传输中被丢失的情况下，将不知道server是否已准备好，不知道server建立什么样的序列号，client甚至怀疑server是否收到自己的连接请求分组。在这种情况下，client认为连接还未建立成功，将忽略server发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h3 id="TCP的具体状态图可参考："><a href="#TCP的具体状态图可参考：" class="headerlink" title="TCP的具体状态图可参考："></a>TCP的具体状态图可参考：</h3><p><img src="http://i.imgur.com/7HzcDvp.png" alt="tcpstatus"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/Android-Activity启动过程/" itemprop="url">
                  Android Activity启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android-Activity的启动过程"><a href="#Android-Activity的启动过程" class="headerlink" title="Android Activity的启动过程"></a>Android Activity的启动过程</h2><h3 id="Android进程创建"><a href="#Android进程创建" class="headerlink" title="Android进程创建"></a>Android进程创建</h3><p>应用程序的入口一般来说，我们都认为是Launcher Activity的onCreate方法，但追求根本，Android应用程序的入口应该是ActivityThread的main方法。</p>
<p><strong>ActivityThread类</strong>：该类为应用程序的主线程类，所有的应用程序都有且仅有一个ActivityThread类，程序的入口为该类中的static main()函数。</p>
<p><strong>Activity类</strong>：该类为APK（AndroidPackage，是一种通过AndroidSDK编译的工程打包成的安装程序文件）程序的一个最小运行单元，一个APK程序中可以包含多个Activity对象，ActivityThread主类会根据用户操作选择运行哪个Activity对象。</p>
<p><strong>ActivityManagerService类</strong>：简称AMS，它的作用是管理所有应用程序中的Activity。</p>
<pre><code>//ActivityThread的main方法

public static void main(String[] args) {
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    Security.addProvider(new AndroidKeyStoreProvider());

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    AsyncTask.init();

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><p>如上所示，其main方法中 初始化了并构建了主线程Looper。</p>
<p>至于，ActivityThread在是什么时候被调用，如下：</p>
<pre><code>// 在ActivityManagerService.java中：  

Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,  
                app.processName, uid, uid, gids, debugFlags,  
                app.info.targetSdkVersion, null, null);  
</code></pre><p>对于应用程序的创建，最终通过 AMS 调度Process.start()静态方法来启动新程序,实际上最终将调用其main函数.</p>
<p>那么，应用程序是通过怎样的一个方式通知创建其进程的？</p>
<p>应用程序是用过向socket服务端写数据，把创建进程的请求通过socket通讯方式来让framework的进程孵化类zygote创建新进程。Zygote进程、SystemServer进程、各APK进程和创建进程的socket服务端/客户端的关系如下图所示：</p>
<p><img src="http://i.imgur.com/F1FDTyz.png" alt="zygote"></p>
<blockquote>
<p>Android进程孵化环境</p>
<p>当Android内核启动后，此时系统的状态和普通的Linux系统基本相同，通过配置Android中的init.rc文件，可以指定内核启动后都要执行什么程序，而在此配置文件中指定的之后所要启动的程序才是Android系统和普通Linux应用系统的区别。Android系统里init.rc中所启动的一个重要进程被称作zygote进程，也称为“种子进程”，从进程的角度来看，种子进程仅仅是一个Linux进程而已，它和一个只包含main()函数的C程序所产生的进程是同一个级别，但种子进程里面所运行的程序基本上就是Android内核的精华所在，其内部主要完成了两件事情。第一件事情是装载了一段程序代码，这些代码都是用C语言写的，这段代码的作用只是为了能够执行Java编译器编译出的字节码，功能类似Java虚拟机，在Android中称为Dalvik虚拟机。第二件事情必须基于第一件事情之后，即当Dalvik虚拟机代码初始化完成后，开始执行ZygoteInit.java类中的main()函数。ZygoteInit.java这个Jar包的目录位置信息也是在init.rc中进行配置的，是使用一个“zygote”标志符，Dalvik虚拟机就会从init.rc配置项的键值对中得到ZygoteInit类所在的Jar包，而这个Jar包正是Android的另一个核心–framework.jar。</p>
<p>接下ZygoteInit类中main()函数所做的事情和Linux本身就没多大关系了，该main()函数中才刚刚开始启动Android的核心功能。首先加载一些类文件，这些类将作为以后所有其它Apk程序共享的类，接着，会创建一个Socket服务端，该服务端将用于通过Socket启动新进程。zygote进程被称为“种子”进程的原因就是，当其内部的Socket服务端收到启动新的Apk进程的请求时，会使用Linux的一个系统调用folk()函数从自身复制出一个新的进程，新进程和Zygote进程将共享已经装载的类，这些类都是在framework.jar中定义的。</p>
</blockquote>
<pre><code>// ZygoteInit.java的main函数如下：  
public static void main(String argv[]) {  
    try {  
        …  
        registerZygoteSocket(); // 注册一个socket server来监听zygote命令  
        preloadClasses();//预加载java class  
        preloadResources();//预加载资源文件  
        …  
        gc();/*初始化GC垃圾回收机制*/  
        if (argv[1].equals(&quot;true&quot;)) {  

            /* 通过main中传递过来的第二个参数startsystemserver=”true” 启动systemserver, 在startSystemServer()中会fork一个新的进程命名为system_server， 执行的是com.android.server包中的SystemServer.java文件中的main函数*/  

            startSystemServer();
             ///*************  
        } else if(…)   
        …

        if (ZYGOTE_FORK_MODE) {  
             runForkMode();      /*将进入Zygote的子进程*/  
        } else {  
             runSelectLoopMode();/* Zygote进程进入无限循环，不再返回。接下来的zygote将会作为一个孵化服务进程来运行。*/  
        }  
        closeServerSocket();  
    }  
    …  
}  
</code></pre><p>简而言之：android程序进程创建的整个流程如下</p>
<ul>
<li>Application层的程序发起创建应用程序的命令；</li>
<li>Ams调度框架通过framework发起socket通讯通知新进程创建；</li>
<li>zygote孵化进程接收socket信息并调用内核创建新进程；</li>
</ul>
<p>也就是说 ，最终是通过zygote fork一个应用进程。</p>
<p>综上所述，创建程序新进程的任务最关键就是zygote进程。Zygote进程起到一个承上启下的作用。对于framework，zygote进程接收上层应用通过socket发送过来的新进程创建命令，对于kernel而言，zygote进程主要调用了内核的fork()系统调用来进行新进程的创建，所以zygote在android系统中扮演一个非常重要的角色，是新进程创建的一个孵化器。</p>
<p><img src="http://i.imgur.com/mDrhXtj.png" alt="process-flow"></p>
<p>Reference: </p>
<ul>
<li><a href="https://android.googlesource.com/" title="https://android.googlesource.com/" target="_blank" rel="external">Android 源码 repo</a></li>
<li><a href="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" title="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" target="_blank" rel="external">Android Anatomy and Physiology</a></li>
<li>柯元旦《android内核剖析》电子工业出版社</li>
</ul>
<h3 id="Activity启动"><a href="#Activity启动" class="headerlink" title="Activity启动"></a>Activity启动</h3><p>Android应用程序启动过程，即为LauncherActivity的启动过程，Android应用程序从Launcher启动 程序 流程如下所示：</p>
<pre><code>/***************************************************************** 
  * Launcher通过Binder告诉ActivityManagerService， 
  * 它将要启动一个新的Activity； 
  ****************************************************************/  
 Launcher.startActivitySafely-&gt;    
 Launcher.startActivity-&gt;

     //要求在新的Task中启动此Activity    
     //intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)    
     Activity.startActivity-&gt;    
     Activity.startActivityForResult-&gt;    
     Instrumentation.execStartActivity-&gt;    

     // ActivityManagerNative.getDefault()返回AMS Proxy接口    
     ActivityManagerNative.getDefault().startActivity-&gt;    
     ActivityManagerProxy.startActivity-&gt;    

        ActivityManagerService.startActivity-&gt; (AMS)    
        ActivityManagerService.startActivityAsUser-&gt;     

         ActivityStack.startActivityMayWait-&gt;    
        ActivityStack.resolveActivity(获取ActivityInfo)    
           //aInfo.name为main Activity,如：com.my.test.MainActivity    
           //aInfo.applicationInfo.packageName为包名，如com.my.test    
         ActivityStack.startActivityLocked-&gt;    
           //ProcessRecord callerApp; 调用者即Launcher信息    
           //ActivityRecord sourceRecord; Launcher Activity相关信息    
           //ActivityRecord r=new ActivityRecord(...)，将要创建的Activity相关信息      
         ActivityStack.startActivityUncheckedLocked-&gt;    
          //Activity启动方式：ActivityInfo.LAUNCH_MULTIPLE/LAUNCH_SINGLE_INSTANCE/    
          //             ActivityInfo.LAUNCH_SINGLE_TASK/LAUNCH_SINGLE_TOP)    
          // 创建一个新的task,即TaskRecord,并保存在ActivityRecord.task中    
          //r.setTask(new TaskRecord(mService.mCurTask, r.info, intent), null, true)    
          // 把新创建的Activity放在栈顶       
          ActivityStack.startActivityLocked-&gt;    
          ActivityStack.resumeTopActivityLocked-&gt;    
          ActivityStack.startPausingLocked (使Launcher进入Paused状态)-&gt;      

  /***************************************************************** 
   * AMS通过Binder通知Launcher进入Paused状态 
   ****************************************************************/  
   ApplicationThreadProxy.schedulePauseActivity-&gt;     
   //private class ApplicationThread extends ApplicationThreadNative    
   ApplicationThread.schedulePauseActivity-&gt;    

   ActivityThread.queueOrSendMessage-&gt;    

    // 调用Activity.onUserLeaveHint    
    // 调用Activity.onPause    
    // 通知activity manager我进入了pause状态    
    ActivityThread.handlePauseActivity-&gt;    

    /***************************************************************** 
     * Launcher通过Binder告诉AMS，它已经进入Paused状态 
     ****************************************************************/  
    ActivityManagerProxy.activityPaused-&gt;    
    ActivityManagerService.activityPaused-&gt;    
    ActivityStack.activityPaused-&gt;(把Activity状态修改为PAUSED)    
    ActivityStack.completePauseLocked-&gt;    

    // 参数为代表Launcher这个Activity的ActivityRecord    
    // 使用栈顶的Activity进入RESUME状态    
    ActivityStack.resumeTopActivityLokced-&gt;    
    //topRunningActivityLocked将刚创建的放于栈顶的activity取回来    
    // 即在ActivityStack.startActivityUncheckedLocked中创建的    

    /***************************************************************** 
     * AMS创建一个新的进程，用来启动一个ActivityThread实例， 
     * 即将要启动的Activity就是在这个ActivityThread实例中运行 
     ****************************************************************/  
    ActivityStack.startSpecificActivityLocked-&gt;    

     // 创建对应的ProcessRecord    
     ActivityManagerService.startProcessLocked-&gt;    

          // 启动一个新的进程    
          // 新的进程会导入android.app.ActivityThread类，并且执行它的main函数,    
          // 即实例化ActivityThread, 每个应用有且仅有一个ActivityThread实例    
          Process.start(&quot;android.app.ActivityThread&quot;,...)-&gt;    

          // 通过zygote机制创建一个新的进程    
          Process.startViaZygote-&gt;    

          // 这个函数在进程中创建一个ActivityThread实例，然后调用    
          // 它的attach函数，接着就进入消息循环    
          ActivityThread.main-&gt;    

      /***************************************************************** 
       * ActivityThread通过Binder将一个ApplicationThread类的Binder对象 
       * 传递给AMS，以便AMS通过此Binder对象来控制Activity整个生命周期 
       ****************************************************************/  
      ActivityThread.attach-&gt;    
      IActivityManager.attachApplication(mAppThread)-&gt;    
      ActivityManagerProxy.attachApplication-&gt;    
      ActivityManagerService.attachApplication-&gt;    

      // 把在ActivityManagerService.startProcessLocked中创建的ProcessRecord取出来    
      ActivityManagerService.attachApplicationLocked-&gt;    

      /***************************************************************** 
       * AMS通过Binder通知ActivityThread一切准备OK,它可以真正启动新的Activity了 
       ****************************************************************/              
      // 真正启动Activity    
      ActivityStack.realStartActivityLocked-&gt;    
      ApplicationThreadProxy.scheduleLaunchActivity-&gt;    
      ApplicationThread.scheduleLaunchActivity-&gt;    
      ActivityThread.handleLaunchActivity-&gt;    
        // 加载新的Activity类，并执行它的onCreate    
        ActivityThread.performLaunchActivity    
           /*---------------------------------------------
           1) Instrumentation.newActivity: 加载新类，即创建Activity对象；  
           2) ActivityClientRecord.packageInfo.makeApplication：创建Application对象；  
              &lt;LoadedApk.makeApplication&gt;  
           3) Activity.attach(Context context, ActivityThread aThread,  
                 Instrumentation instr, IBinder token, int ident,  
                 Application application, Intent intent, ActivityInfo info,  
                 CharSequence title, Activity parent, String id,  
                 NonConfigurationInstances lastNonConfigurationInstances,  
                 Configuration config)：把Application attach到Activity, 即把Activtiy  
                                        相关信息设置到新创建的Activity中  
           4) Instrumentation.callActivityOnCreate：调用onCreate；
            ---------------------------------------------*/    

        // 使用Activity进入RESUMED状态，并调用onResume    
        ActivityThread.handleResumeActivity    
</code></pre><p>从Activity的启动流程中，我们可以看到几个比较重要的类：</p>
<h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h4><p>顾名思义，仪器仪表，用于在应用程序中进行“测量”和“管理”工作。一个应用程序中只有一个Instrumentation实例对象，且每个Activity都有此对象的引用。Instrumentation将在任何应用程序运行前初始化，可以通过它监测系统与应用程序之间的所有交互，即类似于在系统与应用程序之间安装了个“窃听器”。</p>
<p>当ActivityThread 创建(callActivityOnCreate)、暂停、恢复某个Activity时，通过调用此对象的方法来实现，如：</p>
<p>1) 创建: callActivityOnCreate </p>
<p>2) 暂停: callActivityOnPause</p>
<p>3) 恢复: callActivityOnResume</p>
<h4 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h4><p>AMS提供的主要功能：</p>
<ul>
<li>统一调度各应用程序的Activities；</li>
<li>内存管理</li>
<li>进程管理</li>
</ul>
<h5 id="启动一个Activity的方式"><a href="#启动一个Activity的方式" class="headerlink" title="启动一个Activity的方式"></a>启动一个Activity的方式</h5><ul>
<li>在应用程序中调用startActivity()启动指定Activity；</li>
<li>在Launcher中点击一个应用程序的icon，启动新的Activity；</li>
<li>按“back”返回键，结束当前Activity，返回到上一个Activity；</li>
<li>长按“Home”键显示当前正在运行的程序列表，从中选择一个要启动的Activity；</li>
</ul>
<p>这四种方式最终都会按第一种方式进行Activity的启动，区别主要在于前端消息的接受和处理上不同。</p>
<h4 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h4><p>ActivityManagerService使用它来管理系统中所有的Activities的状态，Activities使用stack的方式进行管理。它是真正负责做事的家伙，很勤快的，但外界无人知道！</p>
<h4 id="TaskRecord类"><a href="#TaskRecord类" class="headerlink" title="TaskRecord类"></a>TaskRecord类</h4><p>ActivityManagerService中使用任务的概念来确保Activity启动和退出的顺序。TaskRecord中的几个重要变量如下：</p>
<pre><code>final int taskId;       // 每个任务的标识.
Intent intent;          // 创建该任务时对应的intent
int numActivities;   //该任务中的Activity数目
final ArrayList&lt;ActivityRecord&gt; mActivities = new ArrayList&lt;ActivityRecord&gt;();  //按照出现的先后顺序列出该任务中的所有Activity
</code></pre><h4 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a>ActivityRecord</h4><p>ActivityManagerService使用ActivityRecord数据类来保存每个Activity的信息，ActivityRecord类基于IApplicationToken.Stub类，也是一个Binder,所以可以被IPC调用。</p>
<p>主要包含的变量有：</p>
<ul>
<li><p>环境信息：Activity的工作环境，比如进程名称、文件路径、数据路径、图标、主题等，这些信息一般是固定的，比如以下变量：</p>
<pre><code>final String packageName; // the package implementing intent&apos;s component
final String processName; // process where this component wants to run
final String baseDir;   // where activity source (resources etc) located
final String resDir;   // where public activity source (public resources etc) located
final String dataDir;   // where activity data should go
int theme;              // resource identifier of activity&apos;s theme.
int realTheme;          // actual theme resource we will use, never 0.
</code></pre></li>
<li><p>运行状态数据信息：如idle、stop、finishing等，一般为boolean类型，如下</p>
<pre><code>boolean haveState;      // have we gotten the last activity state?
boolean stopped;        // is activity pause finished?
boolean delayedResume;  // not yet resumed because of stopped app switches?
boolean finishing;      // activity in pending finish list?
boolean configDestroy;  // need to destroy due to config change?
</code></pre></li>
</ul>
<h4 id="ProcessRecord—记录了一个进程的相关信息。"><a href="#ProcessRecord—记录了一个进程的相关信息。" class="headerlink" title="ProcessRecord—记录了一个进程的相关信息。"></a>ProcessRecord—记录了一个进程的相关信息。</h4><p>~\frameworks\base\services\java\com\android\server\am</p>
<p>一般情况下，一个应用程序（APK）运行会对应一个进程，而ProcessRecord就是用来记录一个进程的相关信息，主要包含以下几个方面：</p>
<ul>
<li><p>进程文件信息：与该进程对应的APK文件的内部信息，如：</p>
<pre><code>final ApplicationInfo info; // all about the first app in the process
final String processName;   // name of the process
final ArrayMap&lt;String, ProcessStats.ProcessState&gt; pkgList 
        = new ArrayMap&lt;String, ProcessStats.ProcessState&gt;();   //保存进程中所有APK文件包名
</code></pre></li>
<li><p>进程的内存状态信息：用于Linux系统的out of memory(OOM)情况的处理，当发生内存紧张时，Linux系统会根据进程的内存状态信息杀掉低优先级的进程，包括的变量有：</p>
<pre><code>int maxAdj;                 // Maximum OOM adjustment for this process
int curRawAdj;              // Current OOM unlimited adjustment for this process
int setRawAdj;              // Last set OOM unlimited adjustment for this process
int curAdj;                 // Current OOM adjustment for this process
int setAdj;                 // Last set OOM adjustment for this process
</code></pre><p> 变量中Adj的含义是调整值（adjustment）</p>
</li>
<li><p>进程中包含的Activity、ContentProvider、Service、Receiver等，如下</p>
<pre><code>final ArrayList&lt;ActivityRecord&gt; activities = new ArrayList&lt;ActivityRecord&gt;();
final ArraySet&lt;ServiceRecord&gt; services = new ArraySet&lt;ServiceRecord&gt;();
final ArraySet&lt;ServiceRecord&gt; executingServices = new ArraySet&lt;ServiceRecord&gt;();
final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;ConnectionRecord&gt;();
final ArraySet&lt;ReceiverList&gt; receivers = new ArraySet&lt;ReceiverList&gt;();
final ArrayMap&lt;String, ContentProviderRecord&gt; pubProviders = new ArrayMap&lt;String,             ContentProviderRecord&gt;();
final ArrayList&lt;ContentProviderConnection&gt; conProviders = new ArrayList&lt;ContentProviderConnection&gt;();
</code></pre></li>
</ul>
<h4 id="IApplicationThread接口AMS-gt-Application"><a href="#IApplicationThread接口AMS-gt-Application" class="headerlink" title="IApplicationThread接口AMS-&gt;Application"></a>IApplicationThread接口AMS-&gt;Application</h4><p>IApplicationThread为AMS作为客户端访问Application服务器端的Binder接口。当创建Application时，将把此Binder对象传递给AMS，然后AMS把它保存在mProcessNames.ProcessRecord.thread中。当需要通知Application工作时，则调用IApplicationThread中对应的接口函数。</p>
<p><img src="http://i.imgur.com/E67npgC.png" alt="IApplicationThread"></p>
<p>Reference:</p>
<p><a href="http://www.kancloud.cn/digest/androidframeworks/127785" title="http://www.kancloud.cn/digest/androidframeworks/127785" target="_blank" rel="external">http://www.kancloud.cn/digest/androidframeworks/127785</a></p>
<h4 id="关于Activity启动的流程图"><a href="#关于Activity启动的流程图" class="headerlink" title="关于Activity启动的流程图"></a>关于Activity启动的流程图</h4><p><img src="http://i.imgur.com/Vie24ZR.jpg" alt="launcher-flow"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/android-anr分析/" itemprop="url">
                  Android ANR 分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>什么是ANR</li>
<li>ANR产生的原因</li>
<li>ANR流程分析</li>
<li>发生ANR如何定位</li>
<li>如何避免和解决ANR</li>
</ul>
<p>refer:<a href="http://developer.android.com/intl/zh-cn/training/articles/perf-anr.html#anr" title="keeping your app response" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/training/articles/perf-anr.html#anr</a></p>
<p><strong>1.什么是ANR</strong></p>
<ul>
<li>ANR:Application Not Responding，即应用无响应</li>
<li>为用户在主线程长时间被阻塞是提供交互，提高用户体验；</li>
<li>android系统自身的一种检测机制</li>
</ul>
<p><strong>1.1 ANR的类型</strong></p>
<p>ANR一般有三种类型：</p>
<ol>
<li><p>KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应</p>
</li>
<li><p>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成</p>
</li>
<li><p>ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成</p>
</li>
</ol>
<blockquote>
<ul>
<li>No response to an input event (such as key press or screen touch events) within 5 seconds.</li>
<li>A BroadcastReceiver hasn’t finished executing within 10 seconds.</li>
</ul>
</blockquote>
<p><strong>1.1.1 KeyDispatchTimeout</strong></p>
<p>Akey or touch event was not dispatched within the specified time（按键或触摸事件在特定时间内无响应）</p>
<p>具体的超时时间的定义在framework下的ActivityManagerService.java</p>
<p>//How long we wait until we timeout on key dispatching.</p>
<p>staticfinal int KEY_DISPATCHING_TIMEOUT = 5*1000</p>
<p><strong>2.ANR产生的原因</strong></p>
<p>超时时间的计数一般是从按键分发给app开始。超时的原因一般有两种：</p>
<p>(1)当前的事件没有机会得到处理（即UI线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）</p>
<p>(2)当前的事件正在处理，但没有及时完成</p>
<p>(3)需要满足的条件：</p>
<ul>
<li>主线程：只有应用的主线程响应超时才会导致ANR</li>
<li>超时时间（Timeout）:导致ANR的原因不同，系统限定的时间也不同，但只要超过时间上闲，系统就会发出Signal 3，产生ANR</li>
<li>输入操作/特定操作：输入操作指按键、触屏等操作，特定操作指广播、服务中执行耗时方法等。</li>
</ul>
<p><strong>summary：</strong></p>
<p>引起ANR的根本原因总的来说如下：</p>
<ul>
<li><p>应用程序自身引起的</p>
<p>  例如，主线程阻塞（block）、挂起、死锁、死循环、执行耗时操作等</p>
</li>
<li><p>其他应用进程引起的</p>
<p>  例如，其他进程的CPU占用率过高、某一时刻系统CPU负载过高等，都会导致当前进程无法抢到CPU时间片。</p>
</li>
<li><p>IO wait</p>
<p>  文件读写耗时较久，占用CPU时间片较长，导致ANR</p>
</li>
</ul>
<p>提示：如果你在解决其他问题时也需要查看Java进程中各个线程的函数堆栈信息，就可以使用向目标进程发送SIGNAL_QUIT（3）这个技巧。其实这个名称有点误导，它并不会让进程真正退出。<br><strong><br>3.ANR出现流程分析</strong></p>
<ul>
<li><p>输入时间响应超时导致ANR流程</p>
<p>  在系统输入管理服务进程（InputManagerService）中有一个线程（InputDispathcerThread）专门管理输入事件的分发，在该线程处理输入事件的过程中，回调用InputDispatcher对象方法不断的检测处理过程是否超时，一旦超时，则会通过一些列的回调调用InputMethod对象的notifyANR方法，其会最终出发AMS中handler对象的SHOW_NOT_RESPONDING_MSG这个事件，显示ANR对话框。</p>
</li>
<li><p>广播发生ANR流程</p>
<p>  广播分为三类：普通的，有序的，异步的。只有有序（ordered）的广播才会发生超时，而在AndroidManifest中注册的广播都会被当做有序广播来处理，会被放在广播的队列中串行处理。AMS在处理广播队列时，会设置一个超时时间，当处理一个广播达到超时时间的限制时，就会触发BroadcastQueue类对象的processNextBroadcast方法来判断是否超时，如果超时，就会终止该广播，触发ANR对话框。</p>
</li>
<li><p>UI线程</p>
<p>  UI线程主要包括如下：</p>
<ul>
<li>Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick(),etc声明周期方法里</li>
</ul>
<ol>
<li><p>AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel,etc这些异步更改UI界面的方法里</p>
</li>
<li><p>Mainthread handler: handleMessage(), post*(runnable r), getMainLooper(),etc通过handler发送消息到主线程的looper,即占用主线程looper的</p>
</li>
</ol>
</li>
</ul>
<p><strong>4.发生ANR如何定位</strong></p>
<p>系统发生ANR的时候，一般会以以下三种方式记录</p>
<ul>
<li>logcat日志；</li>
<li>/data/anr/traces.txt</li>
<li>dropBox服务；</li>
</ul>
<p><strong>4.1 通过logcat文件分析</strong></p>
<p>logcat文件：</p>
<pre><code>04-01 13:12:11.572 I/InputDispatcher( 220): Application is not responding:Window{2b263310com.android.email/com.android.email.activity.SplitScreenActivitypaused=false}.
5009.8ms since event, 5009.5ms since waitstarted
04-0113:12:11.572 I/WindowManager( 220): Input event 
dispatching timedout sending 
tocom.android.email/com.android.email.activity.SplitScreenActivity

04-01 13:12:14.123 I/Process( 220): Sending signal. PID: 21404 SIG: 3---发生ANR的时间和生成trace.txt的时间
04-01 13:12:14.123 I/dalvikvm(21404):threadid=4: reacting to 
signal 3 
……
04-0113:12:15.872 E/ActivityManager( 220): ANR in 
com.android.email(com.android.email/.activity.SplitScreenActivity)
04-0113:12:15.872 E/ActivityManager( 220): 
Reason:keyDispatchingTimedOut  -----ANR的类型
04-0113:12:15.872 E/ActivityManager( 220): Load: 8.68 / 8.37 / 8.53 --CPU的负载情况
04-0113:12:15.872 E/ActivityManager( 220): CPUusage from 4361ms to 699ms ago ----CPU在ANR发生前的使用情况

04-0113:12:15.872 E/ActivityManager( 220): 5.5%21404/com.android.email: 1.3% user + 4.1% kernel / faults:
10 minor
04-0113:12:15.872 E/ActivityManager( 220): 4.3%220/system_server: 2.7% user + 1.5% kernel / faults: 11
minor 2 major
04-0113:12:15.872 E/ActivityManager( 220): 0.9%52/spi_qsd.0: 0% user + 0.9% kernel
04-0113:12:15.872 E/ActivityManager( 220): 0.5%65/irq/170-cyttsp-: 0% user + 0.5% kernel
04-0113:12:15.872 E/ActivityManager( 220): 0.5%296/com.android.systemui: 0.5% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 100%TOTAL: 4.8% user + 7.6% kernel + 87% iowait
04-0113:12:15.872 E/ActivityManager( 220): CPUusage from 3697ms to 4223ms later:-- ANR后CPU的使用量
04-0113:12:15.872 E/ActivityManager( 220): 25%21404/com.android.email: 25% user + 0% kernel / faults: 191 minor
04-0113:12:15.872 E/ActivityManager( 220): 16% 21603/__eas(par.hakan: 16% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 7.2% 21406/GC: 7.2% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 1.8% 21409/Compiler: 1.8% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 5.5%220/system_server: 0% user + 5.5% kernel / faults: 1 minor
04-0113:12:15.872 E/ActivityManager( 220): 5.5% 263/InputDispatcher: 0% user + 5.5% kernel
04-0113:12:15.872 E/ActivityManager( 220): 32%TOTAL: 28% user + 3.7% kernel
</code></pre><p>从LOG可以看出：</p>
<ul>
<li><p>ANR的类型</p>
<p>  上面的日志课可以看出anr的类型为keyDispatchingTimedOut</p>
</li>
<li><p>CPU的使用情况<br>  CPU的使用情况包括发生ANR之前CPU的负载情况<br>  如果CPU使用量接近100%，说明当前设备很忙，有可能是CPU饥饿导致了ANR<br>  从上面看出 total CPU达到100%,并且 io wait占到87%,所以 说明在主线程进行io操作。</p>
</li>
</ul>
<p>如果CPU使用量很少，说明主线程被BLOCK了</p>
<p>如果IOwait很高，说明ANR有可能是主线程在进行I/O操作造成的</p>
<ul>
<li><p>Thread的状态</p>
<p>  ThreadState (defined at “dalvik/vm/thread.h “)<br>  THREAD_UNDEFINED = -1, /<em> makes enum compatible with int32_t </em>/<br>  THREAD_ZOMBIE = 0, /<em> TERMINATED </em>/<br>  THREAD_RUNNING = 1, /<em> RUNNABLE or running now </em>/<br>  THREAD_TIMED_WAIT = 2, /<em> TIMED_WAITING in Object.wait() </em>/<br>  THREAD_MONITOR = 3, /<em> BLOCKED on a monitor </em>/<br>  THREAD_WAIT = 4, /<em> WAITING in Object.wait() </em>/<br>  THREAD_INITIALIZING= 5, /<em> allocated, not yet running </em>/<br>  THREAD_STARTING = 6, /<em> started, not yet on thread list </em>/<br>  THREAD_NATIVE = 7, /<em> off in a JNI native method </em>/<br>  THREAD_VMWAIT = 8, /<em> waiting on a VM resource </em>/<br>  THREAD_SUSPENDED = 9, /<em> suspended, usually by GC or debugger </em>/  </p>
</li>
</ul>
<p>Thread.java中定义的状态 &nbsp;&nbsp; &nbsp;Thread.cpp中定义的状态&nbsp;&nbsp; &nbsp;说明</p>
<p>TERMINATED&nbsp;&nbsp; &nbsp;ZOMBIE&nbsp;&nbsp; &nbsp;线程死亡，终止运行</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;RUNNING/RUNNABLE&nbsp;&nbsp; &nbsp;线程可运行或正在运行</p>
<p>TIMED_WAITING&nbsp;&nbsp; &nbsp;TIMED_WAIT&nbsp;&nbsp; &nbsp;执行了带有超时参数的wait、sleep或join函数</p>
<p>BLOCKED&nbsp;&nbsp; &nbsp;MONITOR&nbsp;&nbsp; &nbsp;线程阻塞，等待获取对象锁</p>
<p>WAITING&nbsp;&nbsp; &nbsp;WAIT&nbsp;&nbsp; &nbsp;执行了无超时参数的wait函数</p>
<p>NEW&nbsp;&nbsp; &nbsp;INITIALIZING&nbsp;&nbsp; &nbsp;新建，正在初始化，为其分配资源</p>
<p>NEW&nbsp;&nbsp; &nbsp;STARTING&nbsp;&nbsp; &nbsp;新建，正在启动</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;NATIVE&nbsp;&nbsp; &nbsp;正在执行JNI本地函数</p>
<p>WAITING&nbsp;&nbsp; &nbsp;VMWAIT&nbsp;&nbsp; &nbsp;正在等待VM资源</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;SUSPENDED&nbsp;&nbsp; &nbsp;线程暂停，通常是由于GC或debug被暂停</p>
<p>?&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;UNKNOWN&nbsp;&nbsp; &nbsp;未知状态</p>
<p>traces.txt文件</p>
<pre><code>DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 VMWAIT
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=9437 nice=0 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=2 stm=1 core=0
  #00  pc 0000dca0  /system/lib/libc.so (__futex_syscall3+8)
  #01  pc 000121cc  /system/lib/libc.so
  #02  pc 00053aff  /system/lib/libdvm.so (dvmLockThreadList(Thread*)+38)
  #03  pc 0005427b  /system/lib/libdvm.so (dvmCreateInternalThread(long*, char const*, void* (*)(void*), void*)+134)
  #04  pc 00047427  /system/lib/libdvm.so (dvmInitAfterZygote()+274)
  #05  pc 0006580b  /system/lib/libdvm.so
  #06  pc 0006592b  /system/lib/libdvm.so
  #07  pc 00029020  /system/lib/libdvm.so
  #08  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #09  pc 0005fed5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
  #10  pc 0004aee7  /system/lib/libdvm.so
  #11  pc 00048c75  /system/lib/libandroid_runtime.so
  #12  pc 00049691  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const*, char const*)+368)
  #13  pc 00000dcf  /system/bin/app_process
  #14  pc 00017193  /system/lib/libc.so (__libc_init+38)
  #15  pc 00000b34  /system/bin/app_process
  at dalvik.system.Zygote.nativeForkAndSpecialize(Native Method)
  at dalvik.system.Zygote.forkAndSpecialize(Zygote.java:117)
  at com.android.internal.os.ZygoteConnection.runOnce(ZygoteConnection.java:231)
  at com.android.internal.os.ZygoteInit.runSelectLoopMode(ZygoteInit.java:669)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:566)
  at dalvik.system.NativeStart.main(Native Method)
</code></pre><p>logcat文件：</p>
<pre><code>11-05 13:31:39.511 E/ActivityManager(  498): ANR in com.boyaa.engineddz.main

11-05 13:31:39.511 E/ActivityManager(  498): Reason: Executing service com.boyaa.engineddz.main/com.boyaa.boyaaad.service.FloatWindowService

11-05 13:31:39.511 E/ActivityManager(  498): Load: 1.94 / 1.33 / 0.67

11-05 13:31:39.511 E/ActivityManager(  498): CPU usage from 9953ms to 0ms ago:

11-05 13:31:39.511 E/ActivityManager(  498):   32% 11780/com.boyaa.engineddz.main: 30% user + 2.3% kernel / faults: 125 minor

11-05 13:31:39.511 E/ActivityManager(  498):   9.3% 166/surfaceflinger: 3.8% user + 5.5% kernel / faults: 1250 minor

11-05 13:31:39.511 E/ActivityManager(  498):   3.3% 11818/com.boyaa.engineddz.main: 0% user + 3.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.4% 11817/com.boyaa.engineddz.main: 0.4% user + 2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 1.9% user + 0.4% kernel / faults: 71 minor

11-05 13:31:39.511 E/ActivityManager(  498):   2.2% 498/system_server: 1.2% user + 1% kernel / faults: 46 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.7% 11523/com.boyaa.engineddz.main:pushservice: 0% user + 0.7% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.7% 11549/com.boyaa.engineddz.main:dservice_v1: 0.4% user + 0.3% kernel / faults: 182 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.6% 11799/com.boyaa.engineddz.main: 0.4% user + 0.2% kernel / faults: 524 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 126/ueventd: 0% user + 0.5% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 163/netd: 0.2% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 11507/com.boyaa.engineddz.main:dservice_v1: 0.2% user + 0.3% kernel / faults: 2 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.4% 159/vold: 0.1% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.3% 6070/kworker/0:5: 0% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.3% 10092/kworker/u:2: 0% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 262/adbd: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 9849/kworker/0:0: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 10291/kworker/u:3: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 11559/com.boyaa.engineddz.main:pushservice: 0% user + 0.2% kernel / faults: 210 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0% 110/file-storage: 0% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 251/sdcard: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 522/flush-179:0: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0% 1212/com.tencent.mobileqq:MSF: 0% user + 0% kernel / faults: 6 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0% 9022/com.boyaa.engineddz.main: 0% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 10309/kworker/2:2: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 11753/kworker/3:2: 0.1% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 11758/logcat: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 22% TOTAL: 10% user + 4.5% kernel + 7.5% iowait

11-05 13:31:39.511 E/ActivityManager(  498): CPU usage from 2161ms to 2685ms later:

11-05 13:31:39.511 E/ActivityManager(  498):   45% 11780/com.boyaa.engineddz.main: 43% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 43% 11831/Thread-555: 41% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   9.2% 498/system_server: 3.7% user + 5.5% kernel / faults: 16 minor

11-05 13:31:39.511 E/ActivityManager(  498): 7.4% 515/ActivityManager: 1.8% user + 5.5% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 507/FinalizerDaemon: 1.8% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 642/UEventObserver: 1.8% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   7.4% 166/surfaceflinger: 5.5% user + 1.8% kernel / faults: 66 minor

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 452/SurfaceFlinger: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 463/SurfaceFlinger: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 464/EventThread: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 1.1% user + 1.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 2.3% 737/ndroid.systemui: 1.1% user + 1.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.8% 11817/com.boyaa.engineddz.main: 0% user + 2.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11817/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11819/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   1.4% 11799/com.boyaa.engineddz.main: 1.4% user + 0% kernel / faults: 53 minor

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11800/.engineddz.main: 1.4% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   1.4% 11818/com.boyaa.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11818/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11820/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 28% TOTAL: 14% user + 4.3% kernel + 9.5% iowai
</code></pre><p>traces.txt文件：</p>
<pre><code>----- pid 498 at 2015-11-05 13:32:52 -----
Cmd line: system_server

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 NATIVE
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=498 nice=0 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=669 stm=136 core=1
  #00  pc 0000cb90  /system/lib/libc.so (__ioctl+8)
  #01  pc 00027fed  /system/lib/libc.so (ioctl+16)
  #02  pc 00016f61  /system/lib/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+124)
  #03  pc 00017653  /system/lib/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+154)
  #04  pc 000011d9  /system/lib/libsystem_server.so (system_init+312)
  #05  pc 0001fb70  /system/lib/libdvm.so (dvmPlatformInvoke+112)
  #06  pc 0004e8b9  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+360)
  #07  pc 00029020  /system/lib/libdvm.so
  #08  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #09  pc 0006017f  /system/lib/libdvm.so (dvmInvokeMethod(Object*, Method const*, ArrayObject*, ArrayObject*, ClassObject*, bool)+374)
  #10  pc 00067125  /system/lib/libdvm.so
  #11  pc 00029020  /system/lib/libdvm.so
  #12  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #13  pc 0005fed5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
  #14  pc 0004aee7  /system/lib/libdvm.so
  #15  pc 00048c75  /system/lib/libandroid_runtime.so
  #16  pc 00049691  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const*, char const*)+368)
  #17  pc 00000dcf  /system/bin/app_process
  #18  pc 00017193  /system/lib/libc.so (__libc_init+38)
  #19  pc 00000b34  /system/bin/app_process
  at com.android.server.SystemServer.init1(Native Method)
  at com.android.server.SystemServer.main(SystemServer.java:983)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:804)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:571)
  at dalvik.system.NativeStart.main(Native Method)

提示正在执行JNI层函数，导致这一步极有可能就是native层内存不够了，就要通过dumpsys meminfo 来查看下
</code></pre><p>logcat文件：</p>
<pre><code>11-05 15:32:55.465 E/ActivityManager(  498): ANR in com.boyaa.engineddz.main

11-05 15:32:55.465 E/ActivityManager(  498): Reason: Broadcast of Intent { act=com.igexin.sdk.action.lKooQgpZeM7hxbzRkb34f4 flg=0x10 cmp=com.boyaa.engineddz.main/com.boyaa.godsdk.core.GetuiReceiver (has extras) }

11-05 15:32:55.465 E/ActivityManager(  498): Load: 0.42 / 0.27 / 0.25

11-05 15:32:55.465 E/ActivityManager(  498): CPU usage from 6489ms to 25ms ago:

11-05 15:32:55.465 E/ActivityManager(  498):   4.6% 16150/com.boyaa.engineddz.main: 0.3% user + 4.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   4.4% 16149/com.boyaa.engineddz.main: 0.1% user + 4.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.6% 498/system_server: 1.3% user + 1.2% kernel / faults: 61 minor

11-05 15:32:55.465 E/ActivityManager(  498):   2% 16107/com.boyaa.engineddz.main: 0.3% user + 1.7% kernel / faults: 4 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.7% 16126/com.boyaa.engineddz.main: 0.4% user + 1.2% kernel / faults: 264 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.5% 737/com.android.systemui: 1% user + 0.4% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1% 16221/com.boyaa.engineddz.main:pushservice: 0.4% user + 0.6% kernel / faults: 151 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.9% 16173/com.boyaa.engineddz.main:dservice_v1: 0% user + 0.9% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.9% 16188/com.boyaa.engineddz.main:pushservice: 0.4% user + 0.4% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 166/surfaceflinger: 0.1% user + 0.6% kernel / faults: 75 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 14398/kworker/0:0: 0% user + 0.7% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 16212/com.boyaa.engineddz.main:dservice_v1: 0.3% user + 0.4% kernel / faults: 112 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 248/sensors.qcom: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 262/adbd: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 16197/kworker/0:2: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 159/vold: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 163/netd: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 709/MC_Thread: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 719/wpa_supplicant: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 8772/com.boyaa.engineddz.main: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 9486/com.boyaa.engineddz.main: 0% user + 0% kernel / faults: 1 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0% 15494/kworker/0:1: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 15928/kworker/3:0: 0% user + 0.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 15930/kworker/1:0: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 15934/kworker/u:2: 0% user + 0.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 16104/logcat: 0.1% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498): 5.6% TOTAL: 1.1% user + 4% kernel + 0.4% iowait

11-05 15:32:55.465 E/ActivityManager(  498): CPU usage from 2311ms to 2839ms later:

11-05 15:32:55.465 E/ActivityManager(  498):   12% 498/system_server: 5.5% user + 7.4% kernel / faults: 36 minor

11-05 15:32:55.465 E/ActivityManager(  498):     7.4% 515/ActivityManager: 1.8% user + 5.5% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     3.7% 507/FinalizerDaemon: 3.7% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 689/WifiStateMachin: 1.8% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 12027/Binder_D: 1.8% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.3% 262/adbd: 0% user + 2.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     2.3% 262/adbd: 0% user + 2.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 2.3% user + 0% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):     2.3% 737/ndroid.systemui: 1.1% user + 1.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   3.6% 16149/com.boyaa.engineddz.main: 0% user + 3.6% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     3.6% 16149/.engineddz.main: 0% user + 3.6% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16156/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.3% 15494/kworker/0:1: 0% user + 1.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.4% 16126/com.boyaa.engineddz.main: 0% user + 1.4% kernel / faults: 43 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.8% 16150/com.boyaa.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16150/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16152/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.4% 16212/com.boyaa.engineddz.main:dservice_v1: 0% user + 1.4% kernel / faults: 18 minor

11-05 15:32:55.465 E/ActivityManager(  498): 9% TOTAL: 3.3% user + 5.6% kernel
</code></pre><p>traces.txt文件</p>
<pre><code>----- pid 16107 at 2015-11-05 15:32:52 -----
Cmd line: com.boyaa.engineddz.main

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 MONITOR
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=16107 nice=-15 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=475 stm=38 core=3
  at java.lang.ProcessManager.exec(ProcessManager.java:~206)
  - waiting to lock &lt;0x4252a508&gt; (a java.util.HashMap) held by tid=14 (Thread-815)
  at java.lang.ProcessBuilder.start(ProcessBuilder.java:195)
  at com.tencent.stat.common.l.b((null):-1)
  at com.tencent.stat.common.k.z((null):-1)
  at com.tencent.stat.common.c.&lt;init&gt;((null):-1)
  at com.tencent.stat.common.c.&lt;init&gt;((null):-1)
  at com.tencent.stat.common.a.a((null):-1)
  at com.tencent.stat.common.a.&lt;init&gt;((null):-1)
  at com.tencent.stat.a.k.&lt;init&gt;((null):-1)
  at com.tencent.stat.StatService.d((null):-1)
  at com.tencent.stat.StatService.a((null):-1)
  at com.tencent.stat.StatService.startStatService((null):-1)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.tencent.connect.a.a.c(ProGuard:90)
  at com.tencent.connect.auth.QQAuth.&lt;init&gt;(ProGuard:43)
  at com.tencent.connect.auth.QQAuth.createInstance(ProGuard:78)
  at com.tencent.tauth.Tencent.&lt;init&gt;(ProGuard:49)
  at com.tencent.tauth.Tencent.createInstance(ProGuard:57)
  at com.boyaa.godsdk.core.QQShareSDK.initSDK(QQShareSDK.java:149)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.boyaa.godsdk.core.utils.ReflectUtils.invokeMethod(ReflectUtils.java:-1)
  at com.boyaa.godsdk.core.GodSDK.invokeInitPlugin(GodSDK.java:-1)
  at com.boyaa.godsdk.core.GodSDK.access$8(GodSDK.java:-1)
  at com.boyaa.godsdk.core.GodSDK$5.handleMessage(GodSDK.java:-1)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loop(Looper.java:137)
  at android.app.ActivityThread.main(ActivityThread.java:4881)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:804)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:571)
  at dalvik.system.NativeStart.main(Native Method)

死锁导致 anr，可以最终朔源，看看是有谁持有锁，发现是tid=14的线程持有锁，那么就要分析tid=14的线程函数栈，发现时沃商店在执行shell脚本的时候 导致死锁了。
</code></pre><p>如何避免和解决ANR</p>
<p>1&gt;：UI线程尽量只做跟UI相关的工作</p>
<p>2&gt;：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3&gt;：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<p>4&gt;：是在绕不开主线程，可以尝试通过Handler延迟加载</p>
<p>5&gt;.广播中如果有耗时操作，建议放在service中去执行，或者通过handlerThread分发执行。</p>
<p>6&gt;.分析着重点：</p>
<ul>
<li>cpu占用率方面<ul>
<li>可以通过分析各进程的CPU时间占用率，来判断是否为某些进程长期占用CPU导致该进程无法获取到足够的CPU处理时间，而导致ANR</li>
<li>重点关注下CPU的负载，即logcat中Load1(Load: 0.42 / 0.27 / 0.25，即cpu平均负载)，各个进程总的CPU时间占用率，用户CPU时间占用率，核心态CPU时间占用率，以及iowait CPU时间占用率。</li>
</ul>
</li>
<li>内存方面<ul>
<li>主要看当前应用native和dalvik层内存使用情况</li>
<li>结合系统给每个应用分配的最大内存来分析</li>
</ul>
</li>
</ul>
<p>附：cpu 负载</p>
<p>CPU负载/平均负载</p>
<blockquote>
<p>CPU负载是指某一时刻系统中运行队列长度之和加上当前正在CPU上运行的进程数，而CPU平均负载可以理解为一段时间内正在使用和等待使用CPU的活动进程的平均数量。在Linux中“活动进程”是指当前状态为运行或不可中断阻塞的进程。通常所说的负载其实就是指平均负载。<br>用一个从网上看到的很生动的例子来说明（不考虑CPU时间片的限制），把设备中的一个单核CPU比作一个电话亭，把进程比作正在使用和等待使用电话的人，假如有一个人正在打电话，有三个人在排队等待，此刻电话亭的负载就是4。使用中会不断的有人打完电话离开，也会不断的有其他人排队等待，为了得到一个有参考价值的负载值，可以规定每隔5秒记录一下电话亭的负载，并将某一时刻之前的一分钟、五分钟、十五分钟的的负载情况分别求平均值，最终就得到了三个时段的平均负载。<br>实际上我们通常关心的就是在某一时刻的前一分钟、五分钟、十五分钟的CPU平均负载，例如以上日志中这三个值分别是3.85、3.41、3.16，说明前一分钟内正在使用和等待使用CPU的活动进程平均有3.85个，依此类推。在大型服务器端应用中主要关注的是第五分钟和第十五分钟的两个值，但是Android主要应用在便携手持设备中，有特殊的软硬件环境和应用场景，短时间内的系统的较高负载就有可能造成ANR，所以笔者认为一分钟内的平均负载相对来说更具有参考价值。<br>CPU的负载和使用率没有必然关系，有可能只有一个进程在使用CPU，但执行的是复杂的操作；也有可能等待和正在使用CPU的进程很多，但每个进程执行的都是简单操作。<br>实际处理问题时偶尔会遇到由于平均负载高引起的ANR，典型的特征就是系统中应用进程数量多，CPU总使用率较高，但是每个进程的CPU使用率不高，当前应用进程主线程没有异常阻塞，一分钟内的CPU平均负载较高。</p>
</blockquote>
<p>5.本次我爱 主要做的工作：</p>
<p>1）数据测量，以及命令使用</p>
<ul>
<li>通过应用性能工具（traceView/systemTrace(android高版本支持)）等分析各个方法占用时间，为分析打好依据；</li>
<li>通过 adb shell am start -W -n package/activity来测试记录app的启动时间；</li>
<li>通过查看/proc/stat 、 /proc/pid/stat来得到cpu占用率相关信息</li>
<li>通过查看/proc/meminfo、dumpsys meminfo、dumpsys meminfo package|pid来确认单个应用的内存使用情况（此步骤包括采用Heap分析工具分析）</li>
</ul>
<p>2）优化版本</p>
<ul>
<li>第一版本：godsdk全部异步Looper执行</li>
<li>第二版本：分两步，1.解析配置文件异步；2.各个sdk初始化整体在UI中执行</li>
<li>第三版本：分三步，1.解析配置文件异步；2.sdk初始化在UI中执行；3.一次将sdk的初始化post到主线程中；</li>
<li>第四版本：分三步，1.解析配置文件异步；2.各个sdk初始化整体在UI中执行；3.优化具体sdk中的封装；</li>
</ul>
<p>3）修改依据</p>
<ul>
<li>通过分析traceView 文件按照初始化占用时间由长到短列出表格，然后一次采用第三方demo测试确认是否可以异步执行；</li>
<li>分开依次post到主线程 和 同时一起放到主线程，关于上一步数据发现分开和一起其实差别不大，因为导致时间占用较长主要就是那几个sdk导致的，而大多数sdk的初始化占用时间很少，另外，分开post反而会占用更多的资源，导致ANR或者初始化时间更长。</li>
<li>延迟加载</li>
<li>传入数据给客户端，这一步做了两部小改动<ul>
<li>对于那些只有在初始化后才能获取pmode的sdk，做了编译前pmode动态写入操作，即在打包过程中，就把用户动态写入的pmode或者数据写入smali文件中，这样在初始化的时候就避免只有初始化成功后才能获取的情况；</li>
<li>获取pmode不一定要等到初始化成功去获取，只要等到各个sdk对象new成功后就可以获取（提前了，较之前对于异步获取godsdk提供的数据有时候获取不到的情况有所改善）</li>
</ul>
</li>
</ul>
<p>4）整体来说，修改ANR，关键之处就在于各个sdk里的处理了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/如何实现一个缓存系统/" itemprop="url">
                  如何实现一个缓存系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="如何实现一个缓存系统"><a href="#如何实现一个缓存系统" class="headerlink" title="如何实现一个缓存系统"></a>如何实现一个缓存系统</h2><p>试想这样一个场景，当你当你的而应用频繁要运用某一个组件的时候，而这个组件因动态原因都放置在网络或者disk上，这个时候必然会涉及性能的问题，碰到这类问题，我们自然而然的就会想到缓存，那么，我们该如何实现一个缓存系统，或者说是怎么从零开始设计一个缓存系统，接下来，就让我们一步步来见证一个缓存系统的实现。</p>
<h3 id="设计前准备工作"><a href="#设计前准备工作" class="headerlink" title="设计前准备工作"></a>设计前准备工作</h3><p>ok，这个时候我们脑通打开，高速旋转，做之前，我们要想明白这几件事情</p>
<ul>
<li>缓存到那个级别，即缓存到哪里？</li>
<li>如何访问缓存，即如何设计缓存API？</li>
</ul>
<p>带着这几个问题，让问题先转一下，缓存到什么地方，说白了，就是找个地来存储这些中间组件，而这些地方都有什么呢，常见的一般有内存、disk,设置网络（像云、网盘等）。</p>
<p>然后，我们知道要缓存到这些组件到上述说的这些地方上，那么缓存到这些地方上有什么好处呢？提高访问速度，对这个绝对是我们最想要的。</p>
<p>明白了上述，接下来就是如何缓存常用组件到内存、disk、网络上了。</p>
<h3 id="接口API实现"><a href="#接口API实现" class="headerlink" title="接口API实现"></a>接口API实现</h3><p>接下来，我们以实现 内存+disk双缓存设计为例来描述下如何去涉及一个缓存接口的API。</p>
<h4 id="第一步，抽象出一个需要缓存的组件实例"><a href="#第一步，抽象出一个需要缓存的组件实例" class="headerlink" title="第一步，抽象出一个需要缓存的组件实例"></a>第一步，抽象出一个需要缓存的组件实例</h4><pre><code>public Class ComponentBean{

    public void toString(){}
}
</code></pre><h4 id="第二步，设计内存缓存接口"><a href="#第二步，设计内存缓存接口" class="headerlink" title="第二步，设计内存缓存接口"></a>第二步，设计内存缓存接口</h4><p>内存中的缓存接口设计，首先我们想到的是Map,当然如果系统版本高于19，我们可以用ArrayMap,如果key值设计为Long,我们可以使用LongSparseArray.</p>
<ul>
<li>ArrayMap</li>
</ul>
<blockquote>
<p>ArrayMap is a generic key-&gt;value mapping data structure that is designed to be more memory efficient than a traditional HashMap. It keeps its mappings in an array data structure – an integer array of hash codes for each item, and an Object array of the key/value pairs.</p>
</blockquote>
<p>Added in API level 19</p>
<ul>
<li>LongSparseArray</li>
</ul>
<blockquote>
<p>SparseArray mapping longs to Objects. Unlike a normal array of Objects, there can be gaps in the indices. It is intended to be more memory efficient than using a HashMap to map Longs to Objects, both because it avoids auto-boxing keys and its data structure doesn’t rely on an extra entry object for each mapping.</p>
</blockquote>
<p>Added in API level 16</p>
<p>本次设计内存缓存，主要基于最常用的Map来设计。</p>
<pre><code>public interface IMemeoryCache{

    void put(String key, Reference&lt;ComponentBean&gt;value);

    ComponentBean get(String key);
}
</code></pre><p>上述是一个基本的设计，有存有取，那么接下来，要继续扩展一些基本的接口。试想 ，一个内存缓存系统除了存取之外，应该还有什么操作入口？remove?contain？是的，一个操作接口应该还包含一个删除入口、一个查询是否包含入口、一个能获取到当前缓存所有数据的入口、清空当前缓存数据的入口。</p>
<ul>
<li><p>删除入口</p>
<p>  删除，参照JDK Map设计，我们可以定义一下接口</p>
<pre><code>ComponentBean remove(String key);
</code></pre></li>
<li><p>查询是否包含入口</p>
<pre><code>boolean contain(String key);
</code></pre></li>
<li><p>获取到当前缓存所有数据的入口</p>
<p>  这个借口的实现，我们只要能获取到当前缓存中所有key值映射，就可以遍历当前缓存中所有数据了，所以</p>
<pre><code>Collection&lt;String&gt;keys();
</code></pre></li>
<li><p>清空当前缓存数据的入口</p>
<p>  void clear();</p>
</li>
</ul>
<p>最终设计下来，整体应该是：</p>
<pre><code>public interface IMemeoryCache{

    void put(String key, Reference&lt;ComponentBean&gt;value);

    ComponentBean get(String key);

    ComponentBean remove(String key);

    boolean contain(String key);

    Collection&lt;String&gt;keys();

    void clear();
}
</code></pre><p>当然，如果后续有需求，可以继续扩展 IMemeoryCache接口，骚年，拓展吧。</p>
<h4 id="第三步，设计Disk缓存接口"><a href="#第三步，设计Disk缓存接口" class="headerlink" title="第三步，设计Disk缓存接口"></a>第三步，设计Disk缓存接口</h4><p>Disk缓存，骚年们首先想到是什么呢？流操作？对象序列化？定义一个合理的缓存目录？反正，我先想到的是对象序列化，为什么，因为本次示例存储的就是一个对象嘛。</p>
<p>ok,接下来，我们先将我们要存储的对象序列化了</p>
<ul>
<li><p>存储的对象序列化</p>
<p>  package com.haio.uil;</p>
<p>  import android.os.Parcel;<br>  import android.os.Parcelable;</p>
<p>  public class ComponentBean implements Parcelable {</p>
<pre><code>private int componentId;

ComponentBean(Parcel in) {
    super();
    this.componentId = in.readInt();
}

@Override
public int describeContents() {
    return 0;
}

@Override
public void writeToParcel(Parcel paramParcel, int flag) {
    paramParcel.writeInt(componentId);
}

public static final Parcelable.Creator&lt;ComponentBean&gt; CREATOR = new Creator&lt;ComponentBean&gt;() {

    @Override
    public ComponentBean[] newArray(int size) {
        return new ComponentBean[size];
    }

    @Override
    public ComponentBean createFromParcel(Parcel paramParcel) {
        return new ComponentBean(paramParcel);
    }
};
</code></pre><p>  }</p>
</li>
</ul>
<p>在Android中使用序列化，无非两种途经： Parcelable 和 Serializable。</p>
<p>对象序列化的目的：</p>
<p>1）永久性保存对象，保存对象的字节序列到本地文件中；<br>2）通过序列化对象在网络中传递对象；<br>3）通过序列化在进程间传递对象。</p>
<p>要说明一点，本文主讲的对象 并非对象的序列化，所以如何序列化对象就不做重点阐述，但可以给出参考链接<br><a href="http://developer.android.com/intl/zh-cn/reference/android/os/Parcelable.html#PARCELABLE_WRITE_RETURN_VALUE" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/reference/android/os/Parcelable.html#PARCELABLE_WRITE_RETURN_VALUE</a></p>
<p><a href="http://www.developerphil.com/parcelable-vs-serializable/" target="_blank" rel="external">http://www.developerphil.com/parcelable-vs-serializable/</a></p>
<ul>
<li>Disk存储接口设计</li>
</ul>
<p>如Memorycache设计一样，我们先给出一个基本的入口，然后一次扩展</p>
<pre><code>public interface IDiskCache{

    File getDirectory();

    boolean save(String filename, ComponentBean bean) throws IOException;

    File get(String filename);
}
</code></pre><p>上述是一个基本的设计，有存有取，并且可以获取到当前存储的缓存目录，那么接下来，要继续扩展一些基本的接口。试想 ，一个Disk缓存系统除了存取之外，应该还有什么操作入口？remove?资源释放close？是的，disk cache操作接口应该还包含一个删除入口、清空当前缓存数据的入口、关闭流数据入口（毕竟设计IO操作）。</p>
<p>最终设计应该如下：</p>
<pre><code>public interface IDiskCache{

    File getDirectory();

    boolean save(String filename, ComponentBean bean) throws IOException;

    File get(String filename);

    boolean remove(String imageUri);

    void close();

    void clear();
}
</code></pre><p>重要的接口设计完了，接下来就是实现了，后续且听下回分解。</p>
<h2 id="缓存示例"><a href="#缓存示例" class="headerlink" title="缓存示例"></a>缓存示例</h2><p>###MemoryCache缓存</p>
<p>做一个memoryCache缓存系统，想想该如何设计，照之前的接口设计，我们通过Reference来缓存Object，这样并不能保证所缓存的对象一直存在，比如，通过WeakReference来缓存对象，当GCRoot可以遍历到时，就会回收。所以，如果设计缓存，我们在之前的基础上，加一个强引用缓存（有一定数目限制），这样就可以保证有一部分常用对象的重复利用。</p>
<p>重庆-zhusx(327270607)  11:43:52<br>如果你想序列化传递的话…整个对象的成员变量都得序列化<br>这个也就是为什么你之前这么写 会报错.<br>重庆-zhusx(327270607)  11:45:58<br>内部类 会把 外面一层的东西都包进去…也就是 所有对象必须序列话,而且外面一层的..的所有变量都序列化…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T09:28:44+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="haiolv" />
          <p class="site-author-name" itemprop="name">haiolv</p>
          <p class="site-description motion-element" itemprop="description">Just do it</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/haiolv" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://developer.android.com/" target="_blank" title="Android 官网">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Android 官网
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://cstsinghua.github.io/" title="Atypical programmer" target="_blank">Atypical programmer</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hellokugo.github.io/" title="Hellokugo" target="_blank">Hellokugo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://aso210.github.io/" title="Aso210" target="_blank">Aso210</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haiolv</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
