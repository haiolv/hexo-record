<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Just do it">
<meta property="og:type" content="website">
<meta property="og:title" content="Glory Seeker">
<meta property="og:url" content="http://91yang.github.io/index.html">
<meta property="og:site_name" content="Glory Seeker">
<meta property="og:description" content="Just do it">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glory Seeker">
<meta name="twitter:description" content="Just do it">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://91yang.github.io/"/>

  <title> Glory Seeker </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Glory Seeker</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Make progress step by step everyday！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/25/markdown table/" itemprop="url">
                  MarkDown Leaner(表格以及锚).md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-25T17:03:39+08:00" content="2016-07-25">
              2016-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/文本编辑/" itemprop="url" rel="index">
                    <span itemprop="name">文本编辑</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/文本编辑/MarkDown/" itemprop="url" rel="index">
                    <span itemprop="name">MarkDown</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MarkDown-常用技巧"><a href="#MarkDown-常用技巧" class="headerlink" title="MarkDown 常用技巧"></a>MarkDown 常用技巧<a id="begin"></a></h2><p><a href="http://markdownpad.com/" title="http://markdownpad.com/" target="_blank" rel="external">markdown</a>是一种轻量级的「标记语言」，其语法简单有效。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p>
<p>这里对于简单的语法就不做阐述了，由各位客官自行揣摩，本篇小文主要是正对两个方面做一记录和阐述：</p>
<ul>
<li><a href="#markdown_table">MarkDown 表格语法</a>；</li>
<li><a href="#markdown_page_link">MarkDown实现页内跳转</a>；</li>
</ul>
<p>这里是测试业内跳转的部分：</p>
<ul>
<li>测试一<a id="test1"></a></li>
<li><span id="test2">测试二</span></li>
<li><span name="test3">测试三</span></li>
</ul>
<h3 id="MarkDown-简单语法入门"><a href="#MarkDown-简单语法入门" class="headerlink" title="MarkDown 简单语法入门"></a>MarkDown 简单语法入门</h3><p>参考常用的Markdown语法：</p>
<ul>
<li><a href="http://wowubuntu.com/markdown/#list" title="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a></li>
<li><a href="http://daringfireball.net/projects/markdown/syntax" title="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">创始人 John Gruber 的 Markdown 语法说明</a></li>
<li><a href="https://learn.getgrav.org/content/markdown" title="https://learn.getgrav.org/content/markdown" target="_blank" rel="external">Markdown常见语法</a></li>
<li><a href="http://news.cnblogs.com/n/139649/" title="http://news.cnblogs.com/n/139649/" target="_blank" rel="external">为什么我们要学习Markdown的三个理由</a></li>
</ul>
<p>工具集合</p>
<ul>
<li><a href="https://maxiang.io/" title="https://maxiang.io/" target="_blank" rel="external">马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐</a></li>
<li><a href="https://www.getcloudapp.com/" title="https://www.getcloudapp.com/" target="_blank" rel="external">cloudapp ： Easily share anything, anywhere</a></li>
<li><a href="http://www.appinn.com/markdown-tools/" title="http://www.appinn.com/markdown-tools/" target="_blank" rel="external">Markdown 工具补完</a></li>
</ul>
<p>简要说明，使用Markdown的有点：</p>
<ul>
<li>使你你专注文字内容而不是排版样式，安心写作。</li>
<li>使你轻松的导出 HTML、PDF 和本身的 .md 文件，利于编辑以及共享。</li>
<li>使你轻松入门，学习成本较低，并且与各大知名网站兼容，如 Github等，以及各种blog格式，如博客园等，其可读、直观、学习成本低。</li>
</ul>
<p><a href="http://markdownpad.com/" title="http://markdownpad.com/" target="_blank" rel="external">markdown</a>常用语法很简单，可以从上面说的入门中进行学习。<br>下面主要针对 表格和页内跳转进行整理。</p>
<h3 id="MarkDown-表格语法"><a href="#MarkDown-表格语法" class="headerlink" title="MarkDown 表格语法"></a><span id="markdown_table">MarkDown 表格语法</span></h3><p>Markdown的表格语法如下：</p>
<pre><code>| Option | Description |
| ------ | ----------- |
| data   | path to data files to supply the data that will be passed into templates. |
| engine | engine to be used for processing templates. Handlebars is the default. |
| ext    | extension to be used for dest files. |
</code></pre><blockquote>
<p>Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned.</p>
</blockquote>
<p>其对应的Html如下：</p>
<pre><code>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Option&lt;/th&gt;
    &lt;th&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;data&lt;/td&gt;
    &lt;td&gt;path to data files to supply the data that will be passed into templates.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;engine&lt;/td&gt;
    &lt;td&gt;engine to be used for processing templates. Handlebars is the default.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;ext&lt;/td&gt;
    &lt;td&gt;extension to be used for dest files.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>也就是说，上述两种方式都可以实现简单的表格。</p>
<p>如果，你足够细心，你可能会想到，表格单元中的内容对其方式，上述默认对齐方式是按照左对齐的。</p>
<p>但是如果你想让表格中的内容右对齐，或者居中显示呢？其实实现也很简单：</p>
<ul>
<li><p>右对齐</p>
<p>  | Option | Description |<br>  | ——: | ———–: |<br>  | data   | path to data files to supply the data that will be passed into templates. |<br>  | engine | engine to be used for processing templates. Handlebars is the default. |<br>  | ext    | extension to be used for dest files. |</p>
</li>
<li><p>居中对齐</p>
<p>  | Option | Description |<br>  | :——: | :———–: |<br>  | data   | path to data files to supply the data that will be passed into templates. |<br>  | engine | engine to be used for processing templates. Handlebars is the default. |<br>  | ext    | extension to be used for dest files. |</p>
</li>
</ul>
<p>不知道有没有看到修改之处 </p>
<pre><code>&quot;| :------: | :-----------: |&quot;
</code></pre><p>核心就在于这里的修改之处,冒号的添加，如果右边有，就居右显示，左边有就局左显示，左右都有，就居中显示，默认为居左显示。</p>
<p>来个混合的，看看效果</p>
<pre><code>| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre><p>参考：<a href="http://www.ituring.com.cn/article/3452" title="http://www.ituring.com.cn/article/3452" target="_blank" rel="external">Markdown之表格的处理</a>，然后得到转化后的html，复制粘贴到markdown就行。</p>
<p>当然有的时候，我们需要将需要在文章中插入一段表格，或者 将EXCEL表格插入到Markdown中，当然可以用截图，但是截图显然不合适，而且截图不好控制，比如表格过长的情况下。</p>
<p>针对将 将EXCEL表格插入到Markdown中，我们可以通过 <a href="http://pressbin.com/tools/excel_to_html_table/index.html" title="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="external">将EXCEL/Word表格转化成HTML格式的在线网站</a></p>
<p>例如：经excel复制表格内容如下：</p>
<pre><code>编号    城市    国家
1    北京    中国
2    西安    中国
3    纽约    美国
4    巴黎    法国
</code></pre><p>生成html代码：</p>
<pre><code>&lt;table&gt;
   &lt;tr&gt;
      &lt;td&gt;编号&lt;/td&gt;
      &lt;td&gt;城市&lt;/td&gt;
      &lt;td&gt;国家&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;北京&lt;/td&gt;
      &lt;td&gt;中国&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;西安&lt;/td&gt;
      &lt;td&gt;中国&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;纽约&lt;/td&gt;
      &lt;td&gt;美国&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;巴黎&lt;/td&gt;
      &lt;td&gt;法国&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>效果如下：</p>
<table><br>   <tr><br>      <td>编号</td><br>      <td>城市</td><br>      <td>国家</td><br>   </tr><br>   <tr><br>      <td>1</td><br>      <td>北京</td><br>      <td>中国</td><br>   </tr><br>   <tr><br>      <td>2</td><br>      <td>西安</td><br>      <td>中国</td><br>   </tr><br>   <tr><br>      <td>3</td><br>      <td>纽约</td><br>      <td>美国</td><br>   </tr><br>   <tr><br>      <td>4</td><br>      <td>巴黎</td><br>      <td>法国</td><br>   </tr><br>   <tr><br>      <td></td><br>   </tr><br></table>


<p>参考： </p>
<ul>
<li><a href="http://www.wooaii.com/archives/3434.html" title="http://www.wooaii.com/archives/3434.html" target="_blank" rel="external">markdown做表格</a></li>
<li><a href="http://pressbin.com/tools/excel_to_html_table/index.html" title="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="external">Excel/World表格格式转换成Html格式</a></li>
</ul>
<h3 id="MarkDown-业内跳转"><a href="#MarkDown-业内跳转" class="headerlink" title="MarkDown 业内跳转"></a><span id="markdown_page_link">MarkDown 业内跳转</span></h3><p>如果亲们写了一篇很长的文章，要是没有目录的话。阅读起来十分不便。 页内跳转 就能很好的解决这个问题。</p>
<p>业内跳转 这个概念在Html中就有，当然Markdown的语法也可以实现。</p>
<h4 id="Html中的页内跳转"><a href="#Html中的页内跳转" class="headerlink" title="Html中的页内跳转"></a>Html中的页内跳转</h4><p>即HTML 锚（anchor)的实现，当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。</p>
<pre><code>&lt;a name=&quot;label&quot;&gt;锚（显示在页面上的文本）&lt;/a&gt;
</code></pre><p>提示：锚的名称可以是任何你喜欢的名字。</p>
<p>提示：您可以使用 id 属性来替代 name 属性，命名锚同样有效。</p>
<p>例如：</p>
<p>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：</p>
<pre><code>&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;
</code></pre><p>然后，我们在同一个文档中创建指向该锚的链接：</p>
<pre><code>&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;
</code></pre><blockquote>
<p>参考：<a href="http://www.w3school.com.cn/html/html_links.asp" title="http://www.w3school.com.cn/html/html_links.asp" target="_blank" rel="external">w3school:HTML 链接</a></p>
</blockquote>
<h4 id="MarkDown的具体实现"><a href="#MarkDown的具体实现" class="headerlink" title="MarkDown的具体实现"></a>MarkDown的具体实现</h4><p>arkDown的具体实现其实和Html的很类似，也是需要定义类似 锚 的属性，然后通过</p>
<pre><code>[需要显示的名称](#锚的属性)
</code></pre><p>实现跳转。</p>
<p>例如我们点击跳转到开始：</p>
<ul>
<li><a href="#begin">跳转到首页</a></li>
<li><a href="#test1">跳转到测试一</a></li>
<li><a href="#test2">跳转到测试二</a></li>
<li><a href="#test3">跳转到测试三</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/22/Groovy learner/" itemprop="url">
                  Groovy learner.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-22T17:03:39+08:00" content="2016-07-22">
              2016-07-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Groovy-learner"><a href="#Groovy-learner" class="headerlink" title="Groovy learner"></a>Groovy learner</h1><h2 id="gradle插件开发入门"><a href="#gradle插件开发入门" class="headerlink" title="gradle插件开发入门"></a>gradle插件开发入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ul>
<li><strong>step1</strong>: 新建一个Android project，之后，新建一个Android Module项目，类型选择Android Library，然后将新建的Module中除了build.gradle文件外的其余文件全都删除，并删除build.gradle文件中的所有内容。</li>
<li><strong>step2</strong>: 在刚新建的Module中新建文件夹 <strong>src</strong>，接着在src文件目录下新建main文件夹，在main目录下新建 <strong>groovy</strong> 目录。除此在main目录下新建groovy目录外，你还需要在main目录下新建 <strong>resources</strong> 目录。这时候groovy文件夹会被Android识别为groovy源码目录，同理resources目录会被自动识别为资源文件夹。</li>
<li><strong>step3</strong>: 在groovy目录下新建项目包名，如同新建Java包名那样。resources目录下新建文件夹 <strong>META-INF</strong>，META-INF文件夹下新建 <strong>gradle-plugins</strong> 文件夹。</li>
</ul>
<p>按照上述步骤操作完，你会看到如下目录：</p>
<p><img src="http://i.imgur.com/R8P4HIv.png" alt="gradle_directory"></p>
<p>从上面开发步骤中，我们得知，在 src/main 下新建groovy目录，代表我们将通过groovy来开发工程，resources代表资源目录。</p>
<p>接下来，我们引用开发gradle插件的apk，并将其在build.gradle中进行配置。</p>
<h4 id="配置-插件Module的build-gradle"><a href="#配置-插件Module的build-gradle" class="headerlink" title="配置 插件Module的build.gradle"></a>配置 插件Module的build.gradle</h4><p>打开Module的build.gradle</p>
<pre><code>apply plugin: &apos;groovy&apos;
apply plugin: &apos;maven&apos;

dependencies {
    compile gradleApi()
    compile localGroovy()
}

repositories {
    mavenCentral()
}
</code></pre><p>从maven中心仓库中引入 gradleApi()以及localGroovy()。</p>
<h4 id="撰写对应的插件入口"><a href="#撰写对应的插件入口" class="headerlink" title="撰写对应的插件入口"></a>撰写对应的插件入口</h4><p>在 src/main/groovy 目录下新建 groovy类的包名，如上图 com/haio/groovy,然后新建 PluginImpl.groovy groovy类文件。</p>
<pre><code>package com.haio.groovy

import org.gradle.api.Plugin
import org.gradle.api.Project

public class PluginImpl implements Plugin&lt;Project&gt;{

    @Override
    void apply(Project project) {
        project.task(&quot;testPlugin&quot;) &lt;&lt; {
            println &quot;hello gradle plugin&quot;
        }
    }
}
</code></pre><p>注意：如果需要自己修改，将包名替换成自己写的。</p>
<h4 id="映射入口文件"><a href="#映射入口文件" class="headerlink" title="映射入口文件"></a>映射入口文件</h4><p>在 resources/META-INF/gradle-plugins 目录下新建一个properties文件，并将其命名为你到时候想在 其他项目中引用的名称，例如，这里命名成 plugin.test.properties，并在其输入：</p>
<pre><code>implementation-class=com.haio.groovy.PluginImpl
</code></pre><p>注意： </p>
<ul>
<li>该文件的命名就是你只有使用插件的名字，这里命名为plugin.test.properties</li>
<li>implementation-class中引用的类的路径要和 groovy中写的文件一一对应起来，注意包名需要替换为你自己的包名。</li>
</ul>
<p>此去经年，就完成了一简单的gradle插件，这里面创建了一个 叫 testPlugin的task,执行该 task 会输出 “hello gradle plugin”</p>
<h3 id="发布该插件到-本地-仓库"><a href="#发布该插件到-本地-仓库" class="headerlink" title="发布该插件到 本地 仓库"></a>发布该插件到 本地 仓库</h3><p>接着，我们需要将插件发布到maven中央仓库，当然此时，我们先将插件发布到本地仓库进行测试，在module项目下的buidl.gradle文件中新加入发布的代码。</p>
<pre><code>group=&apos;cn.haio.gradle.plugin&apos;
version=&apos;1.0.0&apos;

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: uri(&apos;../repo&apos;))
        }
    }
}
</code></pre><p>完整的 gradleLibarar/build.gradle中的内容如下：</p>
<pre><code>apply plugin: &apos;groovy&apos;
apply plugin: &apos;maven&apos;

dependencies {
    compile gradleApi()
    compile localGroovy()
}

repositories {
    mavenCentral()
}

group=&apos;cn.haio.gradle.plugin&apos;
version=&apos;1.0.0&apos;

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: uri(&apos;../repo&apos;))
        }
    }
}
</code></pre><p>上面中定义的 <strong>group</strong> 和 <strong>version</strong> 的定义会被使用，作为在maven仓库的定位坐标的一部分，group会被作为坐标的groupId，version会被作为坐标的version，而坐标的artifactId组成即当前 <strong>module</strong> 名，我们让其取一个别名moduleName。然后maven本地仓库的目录就是当前项目目录下的repo目录。</p>
<p>此后，在其他Module中引用遵从如下格式</p>
<pre><code>group:artifactId:version
</code></pre><p>这时候，同步更新工程，右侧的gradle Toolbar就会在module下多出一个task。</p>
<p>[[upload]]<br><img src="http://i.imgur.com/CPEYKXy.png" alt="upload"></p>
<p>然后，点击uploadArchives这个Task，就会在项目下多出一个repo目录，里面存着这个gradle插件。</p>
<p>【【repo】】<br><img src="http://i.imgur.com/HbIkeEn.png" alt="repo"></p>
<h3 id="使用发布到本地仓库的gradle插件"><a href="#使用发布到本地仓库的gradle插件" class="headerlink" title="使用发布到本地仓库的gradle插件"></a>使用发布到本地仓库的gradle插件</h3><ul>
<li><p><strong>step1:</strong> 在当前工程的app (即准本引用该插件的Module)的android项目下的gradle.build的文件中加入 dependencies。</p>
<pre><code>buildscript {
    repositories {
        maven {
            url uri(&apos;../repo&apos;)
        }
    }
    dependencies {
        classpath &apos;cn.haio.gradle.plugin:gradlelibrary:1.0.0&apos;
    }
}
</code></pre></li>
<li><p><strong>step2:</strong> 使用该task,在gradle.build 中apply</p>
<pre><code>apply plugin: &apos;plugin.test&apos;
</code></pre></li>
</ul>
<p>apply plugin后面引号内的名字就是前文plugin.test.properties文件的文件名。而class path后面引号里的内容，就是上面grade中定义的group，version以及moduleName所共同决定的，和maven是一样的。</p>
<p>完整的使用例子如下：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.haio.gradle&quot;
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}

dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    testCompile &apos;junit:junit:4.12&apos;
    compile &apos;com.android.support:appcompat-v7:23.1.1&apos;
}

buildscript {
    repositories {
        maven {
            url uri(&apos;../repo&apos;)
        }
    }
    dependencies {
        classpath &apos;cn.haio.gradle.plugin:gradlelibrary:1.0.0&apos;
    }
}
apply plugin: &apos;plugin.test&apos;
</code></pre><p>同步一下gradle，右侧app下other分类下就会多出一个testTask，双击执行这个Task，控制台就会输出刚才我们输入的字符串。<br>[[task]]</p>
<p><img src="http://i.imgur.com/m7cvXwg.png" alt="task"></p>
<pre><code>....
Incremental java compilation is an incubating feature.
:app:testPlugin
hello gradle plugin

BUILD SUCCESSFUL

Total time: 4.049 secs
15:38:39: External task execution finished &apos;testPlugin&apos;.
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/22/Protocol-Buffer-运用/" itemprop="url">
                  Protocol Buffer 运用.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-22T17:03:39+08:00" content="2016-07-22">
              2016-07-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h1><h2 id="Protocol-Buffer简介"><a href="#Protocol-Buffer简介" class="headerlink" title="Protocol Buffer简介"></a>Protocol Buffer简介</h2><p>Protocol buffer是Google推出来的一个序列化结构化数据的库。其提供了一种在各个平台、各个编程语言之间传递结构序列化数据。假使，Android客户端（使用java语言）需要封装一些特定的数据给服务端（使用php或者go），此时通过protocol buffer 就可以将要传递的数据结构化，例如，在java平台就以对象形式，通过 Build模式封装数据等。</p>
<blockquote>
<ul>
<li><p>Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.</p>
</li>
<li><p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</li>
</ul>
</blockquote>
<p>官方地址: <a href="https://developers.google.com/protocol-buffers/" title="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">https://developers.google.com/protocol-buffers/</a></p>
<p>GitHub地址：<a href="https://github.com/google/protobuf" title="https://github.com/google/protobuf" target="_blank" rel="external">https://github.com/google/protobuf</a></p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>例如，现在要在客户端和服务端传递 Person 数据，其包含 id、name、email三个属性。</p>
<p>protocol 协议（各个平台共用）:</p>
<pre><code>message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;
}
</code></pre><p>然后通过 proto.ext编译，java平台：</p>
<pre><code>Person john = Person.newBuilder()
    .setId(1234)
    .setName(&quot;John Doe&quot;)
    .setEmail(&quot;jdoe@example.com&quot;)
    .build();
output = new FileOutputStream(args[0]);
john.writeTo(output);
</code></pre><p>ios平台：</p>
<pre><code>Person john;
fstream input(argv[1],
    ios::in | ios::binary);
john.ParseFromIstream(&amp;input);
id = john.id();
name = john.name();
email = john.email();
</code></pre><h2 id="Protocol-Buffer运用"><a href="#Protocol-Buffer运用" class="headerlink" title="Protocol Buffer运用"></a>Protocol Buffer运用</h2><p>本篇文章旨在记录Protocol 库的使用 以及proto.ext即相关jar包的编译。</p>
<p>使用protobuf，需要两个部分：</p>
<ul>
<li>install the protocol compiler ，例如安装proto.exe（以windows平台为例，如下若不特殊说明，都以windows平台作说明），其用于编译 .proto文件；</li>
<li>install the protobuf runtime for your chosen programming language,即安装所选择语言对应的支持库。例如，正对java平台，你需要 依赖 protobuf-java-3.0.0-beta-2.jar</li>
</ul>
<blockquote>
<p>To install protobuf, you need to install the protocol compiler (used to compile .proto files) and the protobuf runtime for your chosen programming language.</p>
</blockquote>
<p>注意：protobuf的compiler和runtime library版本要对应起来。</p>
<p>Protocol Buffer使用一般包含以下几个步骤。</p>
<h3 id="1-proto-exe可执行文件的获取-Protocol-Compiler-Installation"><a href="#1-proto-exe可执行文件的获取-Protocol-Compiler-Installation" class="headerlink" title="1. proto.exe可执行文件的获取(Protocol Compiler Installation)"></a>1. proto.exe可执行文件的获取(Protocol Compiler Installation)</h3><p>proto compiler是干什么的？</p>
<p>其就是用来 对 .proto文件进行编译的。</p>
<p>maven仓库获取地址：<a href="http://repo1.maven.org/maven2/com/google/protobuf/protoc/" title="http://repo1.maven.org/maven2/com/google/protobuf/protoc/" target="_blank" rel="external">protocol compiler protocol可执行文件</a></p>
<p>当前 protocol compiler使用C++来写的，如果当前非C++的使用者，最简单的办法就是从官网上下载对应的文件<br><a href="https://github.com/google/protobuf/releases" title="https://github.com/google/protobuf/releases" target="_blank" rel="external">protobuf releases 下载</a>。</p>
<p>当然你也可以自己编译 protobuf，具体源码也可以在 <a href="https://github.com/google/protobuf/releases" title="https://github.com/google/protobuf/releases" target="_blank" rel="external">protobuf 源码 下载</a>。</p>
<h3 id="2-生成-对应语言-proto-运行时依赖库-Protobuf-Runtime-Installation"><a href="#2-生成-对应语言-proto-运行时依赖库-Protobuf-Runtime-Installation" class="headerlink" title="2. 生成 对应语言 proto 运行时依赖库(Protobuf Runtime Installation)"></a>2. 生成 对应语言 proto 运行时依赖库(Protobuf Runtime Installation)</h3><p>以java平台为例，生成对应的依赖库，也就是 支持 通过 proto.exe编译 用户 .proto文件生成的java文件的library jar包。</p>
<p>具体的 runntime library源码，可在 <a href="https://github.com/google/protobuf/releases" title="https://github.com/google/protobuf/releases" target="_blank" rel="external">protobuf releases版本目录</a>进行下载。</p>
<p>具体语言对应的 结构化序列化过程都在这个 依赖库中。</p>
<p>下载java平台相关的 protocol runtime library 具体可参考 <a href="https://github.com/google/protobuf/tree/master/java" title="https://github.com/google/protobuf/tree/master/java" target="_blank" rel="external">Protobuf Runtime Installation for java</a></p>
<p>因为，现在google针对java平台的proto runntime是通过maven进行编译构建的，所以，建议以maven的形式完成对proto。</p>
<ul>
<li><p>step1: 下载protobuf runtime library 源码（注意要和之前编译好的 proto.exe版本一致）</p>
<p>  具体的 runntime library源码，可在 <a href="https://github.com/google/protobuf/releases" title="https://github.com/google/protobuf/releases" target="_blank" rel="external">protobuf releases版本目录</a>进行下载。</p>
<p>  <img src="http://i.imgur.com/pH5QVAC.png" alt="download proto"></p>
</li>
</ul>
<ul>
<li><p>step2:解压，并且进入java目录，然后通过命令行 进入对应java目录，并将之前proto.exe放置在 ../src下。</p>
<p> <img src="http://i.imgur.com/EAVVcp9.png" alt="proto directory"></p>
<p> 然后通过命令行进入java目录，此时需要注意几点：</p>
<ul>
<li><p>检查proto compiler 二进制文件版本</p>
<pre><code>D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\src&gt;protoc --version

libprotoc 3.0.0
</code></pre></li>
<li><p>将之前已编译好或者下载好的对应版本的proto.exe放置在 ../src下，如下查询记录</p>
<pre><code>D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\java&gt;
D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\java&gt;cd ../src

D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\src&gt;dir
 驱动器 D 中的卷是 Document
 卷的序列号是 D4A2-99E4

 D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\src 的目录

2016/07/22  11:13    &lt;DIR&gt;          .
2016/07/22  11:13    &lt;DIR&gt;          ..
2016/07/22  11:04    &lt;DIR&gt;          google
2016/07/20  08:23            50,260 Makefile.am
2016/07/20  08:24           819,873 Makefile.in
2016/07/19  05:39         4,060,160 protoc.exe
2016/07/02  04:43             7,195 README.md
2016/07/22  11:04    &lt;DIR&gt;          solaris
               4 个文件      4,937,488 字节
               4 个目录 100,164,812,800 可用字节

D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\src&gt;
</code></pre></li>
<li><p>需要将java目录下maven的构建脚本pom.xml中添加编码格式</p>
<p>  pom.xml类似Ant的build.xml或者gradle的build.gradle配置脚本文件。</p>
<p>  maven构建项目</p>
</li>
</ul>
</li>
</ul>
<pre><code>* ，否则构建会采用操作系统默认的编码，Windows平台中文的话是GBK，而我们在Android平台采用的是UTF_8。添加部分代码如下：

        &lt;properties&gt; 
              &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 
          &lt;/properties&gt;

    ![](http://i.imgur.com/q5WtQgd.png)

reference：[Maven POM Reference](http://maven.apache.org/pom.html &quot;http://maven.apache.org/pom.html&quot;)
</code></pre><ul>
<li><p>step3:检查当前是否已安装maven，如未安装，请下载安装(注意需要安装JDK1.7及其以上版本)</p>
<p>  maven下载地址(目前最新版本3.3.9)，<a href="http://maven.apache.org/" title="maven下载地址" target="_blank" rel="external">http://maven.apache.org/</a>。下载之后解压，然后将解压后得到的目录路径添加到系统path中，这样使得可以直接在命令行使用mvn命令。</p>
<p>  可以通过 </p>
<pre><code>mvn --version
</code></pre><p>  来检查 maven是否正确安装以及其版本。</p>
</li>
<li><p>step4:Run the tests（运行测试）</p>
</li>
</ul>
<p>Notice:</p>
<ul>
<li><p>step5:构建生成jar包</p>
<p>  通过命令行，生成对应的jar</p>
<pre><code>mvn package
</code></pre><p>  [[jar 图]]</p>
<p>  The .jar will be placed in the “target” directory.</p>
<blockquote>
<p>mvn package:The typical invocation for building a Maven project uses a Maven life cycle phase<br>reference: <a href="http://maven.apache.org/run.html" title="http://maven.apache.org/run.html" target="_blank" rel="external">http://maven.apache.org/run.html</a></p>
</blockquote>
</li>
<li><p>step6:将生成的jar包安装到本地maven仓库中（可选）</p>
<p>  通过命令行，生成对应的jar</p>
<pre><code>mvn install
</code></pre><blockquote>
<p>mvn install:Just creating the package and installing it in the local repository for re-use from other projects can be done with</p>
</blockquote>
</li>
</ul>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>经过上述两个步骤，我们拿到了 protoc.exe以及 对应版本的 protobuf的支持库 protobuf-java-3.0.0-beta-4.jar。</p>
<ul>
<li><p>step1 : Defining Your Protocol Format(定义要传递的数据机构的协议格式)</p>
<p>  定义业务要传递的数据协议格式，类似定义xml文件格式一样，其相当于定义要传递的数据的结构。但是相比xml定义，proto格式更简单易懂，并且会提供出对数据操作的对应接口。简单来说，其相当于一个数据结构，对应用程序中要交换的数据做一个定义，包括各种字段的声明等等。其文件扩展名为.proto。对于.proto文件如何定义和其语法规范，请详细阅读<a href="https://developers.google.com/protocol-buffers/docs/proto3" title="Protocol Buffer Language Guide" target="_blank" rel="external">Protocol Buffer Language Guide</a>。这里是proto3版本(最新版本，建议采用)，proto2的也可以参阅<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">proto2 Language Guide</a></p>
<p>  .proto示例(addressbook.proto)：</p>
</li>
</ul>
<pre><code>syntax = &quot;proto3&quot;;
package tutorial;

option java_package = &quot;com.example.tutorial&quot;;
option java_outer_classname = &quot;AddressBookProtos&quot;;
// [END java_declaration]

message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;
}

message AddressBook {
  repeated Person people = 1;
}
</code></pre><ul>
<li><p>step2: 编译生成对应语言的api</p>
<p>  在命令行执行：</p>
<pre><code>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto
</code></pre><p>  SRC_DIR：where your application’s source code lives – the current directory is used if you don’t provide a value；</p>
<p>  DST_DIR：where you want the generated code to go; often the same as $SRC_DIR；</p>
<p>  java_out：Because you want Java classes, you use the –java_out option – similar options are provided for other supported languages.</p>
</li>
</ul>
<pre><code>例如，在f盘将上述的proto写入一个名叫test.proto文件，然后执行：

    F:\&gt;D:\UserProfiles\Haiolv\Downloads\protobuf-3.0.0-beta-4\src\protoc.exe -I . --java_out=. .\test.proto


在F盘下生成文件：F:\com\example\tutorial\AddressBookProtos.java



    // Generated by the protocol buffer compiler.  DO NOT EDIT!
    // source: addres.proto

    package com.example.tutorial;

    public final class AddressBookProtos {
      private AddressBookProtos() {}
      public static void registerAllExtensions(
          com.google.protobuf.ExtensionRegistryLite registry) {
      }

      public static void registerAllExtensions(
          com.google.protobuf.ExtensionRegistry registry) {
        registerAllExtensions(
            (com.google.protobuf.ExtensionRegistryLite) registry);
      }

      public static com.google.protobuf.Descriptors.FileDescriptor
          getDescriptor() {
        return descriptor;
      }
      private static  com.google.protobuf.Descriptors.FileDescriptor
          descriptor;
      static {
        java.lang.String[] descriptorData = {
          &quot;\n\014addres.proto\022\010tutorialB)\n\024com.example.&quot; +
          &quot;tutorialB\021AddressBookProtosb\006proto3&quot;
        };
        com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
            new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
              public com.google.protobuf.ExtensionRegistry assignDescriptors(
                  com.google.protobuf.Descriptors.FileDescriptor root) {
                descriptor = root;
                return null;
              }
            };
        com.google.protobuf.Descriptors.FileDescriptor
          .internalBuildGeneratedFileFrom(descriptorData,
            new com.google.protobuf.Descriptors.FileDescriptor[] {
            }, assigner);
      }

      // @@protoc_insertion_point(outer_class_scope)
    }
</code></pre><p>然后对数据进行操作，具体的 proto语法可以请详细阅读<a href="https://developers.google.com/protocol-buffers/docs/proto3" title="Protocol Buffer Language Guide" target="_blank" rel="external">Protocol Buffer Language Guide</a>。这里是proto3版本(最新版本，建议采用)，proto2的也可以参阅<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">proto2 Language Guide</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/防止动态调试/" itemprop="url">
                  防止动态调试.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-20T10:46:39+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="防止Apk被动态调式"><a href="#防止Apk被动态调式" class="headerlink" title="防止Apk被动态调式"></a>防止Apk被动态调式</h2><p>如何防止自己的apk被第三方动态调式呢？</p>
<p><img src="http://i.imgur.com/wfu7R40.jpg" alt="dynamic-debug"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/17/Android小工具-方法计数统计DexCount-md/" itemprop="url">
                  Android小工具--方法计数统计DexCount.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-17T11:59:52+08:00" content="2016-06-17">
              2016-06-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android小工具–方法计数统计DexCount"><a href="#Android小工具–方法计数统计DexCount" class="headerlink" title="Android小工具–方法计数统计DexCount"></a>Android小工具–方法计数统计DexCount</h2><p>download:<a href="https://github.com/haiolv/tool-android" title="https://github.com/haiolv/tool-android" target="_blank" rel="external">Android小工具–方法计数统计DexCount 下载</a></p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>.
├── dex-method-counts.jar
├── tools.bat
├── app-debug_dexcount.txt


**dex-method-counts.jar**
获得方法的可执行jar包

**tools.bat**
tools.bat：获取某一apk方法数的bat批处理命令
</code></pre><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>将某一个需要查看方法数的apk拖入tools.bat上，然后就会在 当前目录生成 一个名为 “${apk名称}_dexcount.txt”文件，打开该文件，即可以看到具体的方法分布。</p>
<p>such as:</p>
<pre><code>Processing D:\UserProfiles\Haiolv\Downloads\app-debug.apk
Read in 64836 method IDs.
&lt;root&gt;: 64836
    &lt;default&gt;: 1
    adStats: 12
    android: 16841
        accessibilityservice: 6
        accounts: 5
        animation: 12
        app: 349
        bluetooth: 3
        content: 338
.....
</code></pre><p>如上，当将 app-debug.apk  拖入 tools.bat命令后，会在当前目录生成一个 名为 app-debug_dexcount.txt文件，打看我们可以看到该apk先总含有方法数为  64836，bomm..快超过 单个dex所允许的最大方法数了（65536），关于当apk方法数超过Short限制时，请查看 <a href="https://developer.android.com/studio/build/multidex.html" title="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="external">Configure Apps with Over 64K Methods</a></p>
<h3 id="批处理命令详解"><a href="#批处理命令详解" class="headerlink" title="批处理命令详解"></a>批处理命令详解</h3><pre><code>echo 拖入apk包
REM echo &quot;%~f1&quot;
REM echo &quot;%~dp0&quot;
REM echo %0
pushd %~dp0 

if exist ./dexcount.txt (
    rmdir /s /q ./dexcount.txt
)

REM echo %~n1
REM echo %~n1%_dexcount.txt
REM pause

java -jar ./dex-method-counts.jar &quot;%~f1&quot; &gt; ./%~n1%_dexcount.txt
popd
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/Android的事件处理机制/" itemprop="url">
                  Android的事件处理机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T18:59:48+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android的事件处理机制"><a href="#Android的事件处理机制" class="headerlink" title="Android的事件处理机制"></a>Android的事件处理机制</h2><p>Android的事件产生是从我们触摸屏幕开始，在经过Input子系统，最后达到我们的应用程序(或者经过WindowManagerService到达应用程序)。</p>
<p>而其中Input子系统在Java层对应着InputManagerService，其主要在native层，由InputReader读取EventHub的元数据，将这些数据加工成InputEvent，最后发到InputDispatcher，而InputDispatcher则负责将事件发到应用程序，Input子系统流程可以参见这篇文章 <a href="http://www.cnblogs.com/haiming/p/3318614.html" title="Android Framework——之Input子系统" target="_blank" rel="external">Android Framework——之Input子系统</a>。 和 <a href="http://blog.csdn.net/yclzh0522/article/details/6920522" title="http://blog.csdn.net/yclzh0522/article/details/6920522" target="_blank" rel="external">Android 事件捕捉和处理流程分析</a></p>
<p>对于应用层的时间流程，主要是下面的流程图所示：<br><img src="http://i.imgur.com/yugKXH4.png" alt="key-transfer"></p>
<p>其中最后一步就是我们经常说的View事件派发流程。而在流程图中，我们也看到，调了两次DecorView的方法，第一次是调用DecorView的dispatchTouchEvent，它的源码是:</p>
<pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    final Callback cb = getCallback();
    return cb != null &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev)
            : super.dispatchTouchEvent(ev);
}
</code></pre><p>调用了Callback的dispatchTouchEvent，那这个Callback是什么类型呢？</p>
<p>Callback就是Window.Callback，Activity实现了这个接口。在Activity的attach函数中，会调用window的setCallback，将Activity设置给Window。所以这里getCallback返回的就是Activity，最终会调用Activity的dispatchTouchEvent。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>在ACTION_DOWN事件处理的时候会调用onUserInteraction方法，然后调用Window（实际上是PhoneWindow)的superDispatchTouchEvent，如果Window的superDispatchTouchEvent消耗了事件，则直接返回，不会调用Activity的onTouchEvent方法。</p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}
</code></pre><p>而DecorView的superDispatchTouchEvent为:</p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}
</code></pre><p>最终还是调用DecorView的父类的dispatchTouchEvent，DecorView的父类是FrameLayout，它没实现该方法，最终会调用ViewGroup的dispatchTouchEvent方法。从这里开始就进入了view树的事件派发流程了。</p>
<p>此外，关于Android view树的事件派发流程，众说纷纭，给出一篇参考文章</p>
<p>Reference：<a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism/" title="http://www.infoq.com/cn/articles/android-event-delivery-mechanism/" target="_blank" rel="external">Android事件传递机制</a></p>
<p>然后，站在前人的肩膀上，接下俩文章主要做些验证。</p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h3><ul>
<li><p>Activity中dispatchTouchEvent在什么时候调用？</p>
</li>
<li><p>MotionEvent事件向下分发，是通过什么途径？通过dispatchKeyEvent的返回值？</p>
</li>
</ul>
<p>简单列举下工程</p>
<ul>
<li><p>Activity:</p>
<pre><code>// haio.com.event.MainActivity

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;Activity---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
//        boolean isDispatch = super.dispatchTouchEvent(event);
    boolean isDispatch = true;
    System.out.println(&quot;Activity---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}

@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    System.out.println(&quot;Activity---onKeyDown---DOWN&quot;);
    boolean isDown = super.onKeyDown(keyCode, event);
    System.out.println(&quot;Activity---onKeyDown---isDown =&quot; + isDown);
    return isDown;
}
</code></pre></li>
</ul>
<ul>
<li><p>HButton</p>
<p>  View(如 Button等) 涉及事件分发共涉及两个个事件</p>
<ul>
<li>dispatchTouchEvent</li>
<li><p>onTouchEvent</p>
<pre><code>//haio.com.event.widget.HButton
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HButton---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HButton---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HButton---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;HButton---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HButton---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HButton---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HButton---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = true;
    System.out.println(&quot;HButton---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre></li>
</ul>
</li>
<li><p>ViewGroup</p>
<p>  ViewGroup 涉及事件分发共涉及三个事件</p>
<ul>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li><p>onTouchEvent</p>
<pre><code>//haio.com.event.widget.HLinearLayout

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---onTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---onTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---onTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isTouch = super.onTouchEvent(event);
    System.out.println(&quot;HLinearLayout---onTouchEvent---isTouch =&quot; + isTouch);
    return isTouch;
}

@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---UP&quot;);
            break;
        default:
            break;
    }

    boolean isIntercept = super.onInterceptTouchEvent(event);
    System.out.println(&quot;HLinearLayout---onInterceptTouchEvent---isIntercept =&quot; + isIntercept);
    return isIntercept;
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;HLinearLayout---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }
    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = true;
    System.out.println(&quot;HLinearLayout---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre></li>
</ul>
</li>
</ul>
<p>上述代码，细心的小伙伴们会发现，将MainActivity 中dispatchTouchEvent的返回值改为true,并屏蔽掉</p>
<pre><code>super.dispatchTouchEvent(event)
</code></pre><p>的调用，然后分别点击 Button 和 TextView的日志为：</p>
<pre><code>1.点击按钮：
06-14 17:41:58.639 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:41:58.639 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:41:58.689 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:41:58.689 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true

2.点击文本：
06-14 17:41:58.694 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:51:09.684 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:51:09.684 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:51:09.809 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:51:09.809 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
</code></pre><p>然后，我们在将MainActivity 中dispatchTouchEvent的返回值改为false，查看日志：</p>
<pre><code>06-14 17:54:23.509 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:54:23.509 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 17:54:23.524 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:54:23.524 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 17:54:23.579 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:54:23.579 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>从上面，我们得知，dispatchTouchEvent返回true 表明当前view/viewGroup负责处理该事件 ，false表明不负责处理该事件， 从日志打印结果中看出return true是不会有任何区别的。</p>
<p>那么，问题来了，Activity是通过调用上面来分发事件的呢？</p>
<p>我们将 MainActivity 中dispatchTouchEvent 改成如下，放开 super.dispatchTouchEvent(event) 的调用，并且返回true，表示 负责处理该事件。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            System.out.println(&quot;Activity---dispatchTouchEvent---DOWN&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            System.out.println(&quot;Activity---dispatchTouchEvent---MOVE&quot;);
            break;
        case MotionEvent.ACTION_UP:
            System.out.println(&quot;Activity---dispatchTouchEvent---UP&quot;);
            break;
        default:
            break;
    }


    boolean isDispatch = super.dispatchTouchEvent(event);
//        boolean isDispatch = false;
    isDispatch = true;


    System.out.println(&quot;Activity---dispatchTouchEvent---isDispatch =&quot; + isDispatch);
    return isDispatch;
}
</code></pre><p>日志打印为：</p>
<pre><code>06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouch---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---MOVE
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.234 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouch---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---UP
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.239 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.249 17504-17504/haio.com.event I/System.out: HButton---onClick---DOWN
</code></pre><p>事件分发了，这说明：</p>
<p>dispatchTouchEvent返回true 表明当前view/viewGroup负责处理该事件 false表明不负责处理该事件 在MainActivity中 如果你把return值改为false 打印结果和return true是不会有任何区别的 因为你根本就没有向下进行分发 MainActivity中分发是调用super.dispatchTouchEvent的。</p>
<p>注意，一个事件分发的完整过程：</p>
<pre><code>06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 17:58:12.159 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =true
06-14 17:58:12.169 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =true
</code></pre><p>后面三行打印，说明HButton、HLinearLayout、Activity都负责此事件，因此后续事件还会分发到HButton、HLinearLayout、Activity上。</p>
<h4 id="如果-子View不消耗事件，则回溯给Activity进行执行"><a href="#如果-子View不消耗事件，则回溯给Activity进行执行" class="headerlink" title="如果 子View不消耗事件，则回溯给Activity进行执行"></a>如果 子View不消耗事件，则回溯给Activity进行执行</h4><p>当你把HButton中的dispatchTouchEvent返回值改变为false的时候 说明没有调用View.onTouchEvent来消费事件,日志如下：</p>
<pre><code>06-14 18:09:10.934 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---DOWN
06-14 18:09:10.959 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HLinearLayout---onInterceptTouchEvent---isIntercept =false
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouch---DOWN
06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 18:09:11.014 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---MOVE
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---MOVE
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>如上，当你把HButton中的dispatchTouchEvent返回值改变为false的时候 说明没有调用View.onTouchEvent来消费事件, 所以返回之后最终MainActivity的onTouchEvent还是会对Event进行处理, 假如某层dispatchTouchEvent返回值为false,那么后续的move up等等action就不会再被分发到当前层了.</p>
<p>注意，针对以上，下面日志反应一个事件的分发过程</p>
<pre><code>06-14 18:09:10.979 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HButton---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: HLinearLayout---dispatchTouchEvent---isDispatch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---DOWN
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:10.994 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre><p>打印说明HButton、HLinearLayout都不负责此事件（返回false），因此后续事件就不会分发到HButton、HLinearLayout上。</p>
<pre><code>06-14 18:09:11.044 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---UP
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---onTouchEvent---isTouch =false
06-14 18:09:11.049 17504-17504/haio.com.event I/System.out: Activity---dispatchTouchEvent---isDispatch =false
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/TCP_IP--三次握手-四次挥手/" itemprop="url">
                  TCP/IP--三次握手，四次挥手
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T10:23:00+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul>
<li>TCP为什么需要3次握手与4次挥手?</li>
<li>三次握手，四次挥手，为什么要用四次挥手，三次不行吗，当Client收到Server的ack后，Client还能接收来自Server的数据写入吗？</li>
</ul>
<p>或者说是怎么去解释“三次握手，四次挥手”？</p>
<p><img src="http://i.imgur.com/Cn6koqL.png" alt="tcp-head"></p>
<p>符号说明：</p>
<ul>
<li><p>seq:”sequance”序列号，Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
</li>
<li><p>ack:”acknowledge”确认号</p>
</li>
</ul>
<p>标志位，共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li><p>SYN:”synchronize”请求同步标志</p>
</li>
<li><p>ACK:”acknowledge”确认标志”，Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
</li>
<li><p>FIN：finish结束，”Finally”结束标志,释放一个连接。</p>
</li>
<li><p>RST:reset重置，重置连接。</p>
</li>
<li><p>URG:urgent紧急，紧急指针（urgent pointer）有效。</p>
</li>
<li><p>PUS:push传送，接收方应该尽快将这个报文交给应用层。</p>
</li>
</ul>
<p>注意：确认方Ack=发起方Req+1，两端配对。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://i.imgur.com/yrgs5LB.png" alt="tcp1"></p>
<p>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<p>reference:<a href="http://blog.csdn.net/whuslei/article/details/6667471/" title="http://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="external">http://blog.csdn.net/whuslei/article/details/6667471/</a></p>
<p><img src="http://i.imgur.com/uVngHhd.png" alt="tcp_draw"></p>
<ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server端收到TCP数据包之后，由标志位SYN=1知道Client请求简历TPC链接，Server端将标志位ACK和SYN都置为1（1表示有效），Act=J + 1，并随机产生一个Seq序列号，Seq=k，然后将该数据包发给Client端以确认并且同步此链接请求，Server端进入SYN_REVD状态.</p>
</li>
<li><p>第三次握手：CLient端收到确认后，首先检查ACK是否为1，且Ack是否为j+1，如果正确，则将ACK标志置为1，ack=k+1,并将该数据包发送给Server端，Server端检查Ack是否为k+1，ACK是否为1，如果正确，则表示链接建立成功Client和Server进入ESTABLISHED状态，完成三次握手之后，随之C和S就可以互通数据了。</p>
</li>
</ul>
<p>“<strong>三次握手</strong>”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p>
<p>这是因为：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。主要目的防止server端一直等待，浪费资源。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://i.imgur.com/oDESM4a.png" alt="tcp"></p>
<p>服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<p><img src="http://i.imgur.com/g4u6Tko.png" alt="tcp2"></p>
<blockquote>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
</blockquote>
<h3 id="整个过程流程图"><a href="#整个过程流程图" class="headerlink" title="整个过程流程图"></a>整个过程流程图</h3><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：<br><img src="http://i.imgur.com/4VD19KB.jpg" alt="tcp3"></p>
<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><p>【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<p>答：因为TCP链接是全双工模式，因此需要close链接时需要两方都需要单独进行链接释放。当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p>【问题3】为什么收到Server端的确认之后，Client还需要进行第三次“握手”呢？</p>
<p>答：在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！</p>
<p>并且，两次握手可能产生死锁。作为例子，考虑计算机server和client之间的通信，假定client给server发送一个连接请求分组，server收到了这个分组，并发送了确认应答分组。按照两次握手的协定，server认为连接已经成功地建立了，可以开始发送数据分组。可是，client在server的应答分组在传输中被丢失的情况下，将不知道server是否已准备好，不知道server建立什么样的序列号，client甚至怀疑server是否收到自己的连接请求分组。在这种情况下，client认为连接还未建立成功，将忽略server发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h3 id="TCP的具体状态图可参考："><a href="#TCP的具体状态图可参考：" class="headerlink" title="TCP的具体状态图可参考："></a>TCP的具体状态图可参考：</h3><p><img src="http://i.imgur.com/7HzcDvp.png" alt="tcpstatus"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/Android-Activity启动过程/" itemprop="url">
                  Android Activity启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android-Activity的启动过程"><a href="#Android-Activity的启动过程" class="headerlink" title="Android Activity的启动过程"></a>Android Activity的启动过程</h2><h3 id="Android进程创建"><a href="#Android进程创建" class="headerlink" title="Android进程创建"></a>Android进程创建</h3><p>应用程序的入口一般来说，我们都认为是Launcher Activity的onCreate方法，但追求根本，Android应用程序的入口应该是ActivityThread的main方法。</p>
<p><strong>ActivityThread类</strong>：该类为应用程序的主线程类，所有的应用程序都有且仅有一个ActivityThread类，程序的入口为该类中的static main()函数。</p>
<p><strong>Activity类</strong>：该类为APK（AndroidPackage，是一种通过AndroidSDK编译的工程打包成的安装程序文件）程序的一个最小运行单元，一个APK程序中可以包含多个Activity对象，ActivityThread主类会根据用户操作选择运行哪个Activity对象。</p>
<p><strong>ActivityManagerService类</strong>：简称AMS，它的作用是管理所有应用程序中的Activity。</p>
<pre><code>//ActivityThread的main方法

public static void main(String[] args) {
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    Security.addProvider(new AndroidKeyStoreProvider());

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    AsyncTask.init();

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><p>如上所示，其main方法中 初始化了并构建了主线程Looper。</p>
<p>至于，ActivityThread在是什么时候被调用，如下：</p>
<pre><code>// 在ActivityManagerService.java中：  

Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,  
                app.processName, uid, uid, gids, debugFlags,  
                app.info.targetSdkVersion, null, null);  
</code></pre><p>对于应用程序的创建，最终通过 AMS 调度Process.start()静态方法来启动新程序,实际上最终将调用其main函数.</p>
<p>那么，应用程序是通过怎样的一个方式通知创建其进程的？</p>
<p>应用程序是用过向socket服务端写数据，把创建进程的请求通过socket通讯方式来让framework的进程孵化类zygote创建新进程。Zygote进程、SystemServer进程、各APK进程和创建进程的socket服务端/客户端的关系如下图所示：</p>
<p><img src="http://i.imgur.com/F1FDTyz.png" alt="zygote"></p>
<blockquote>
<p>Android进程孵化环境</p>
<p>当Android内核启动后，此时系统的状态和普通的Linux系统基本相同，通过配置Android中的init.rc文件，可以指定内核启动后都要执行什么程序，而在此配置文件中指定的之后所要启动的程序才是Android系统和普通Linux应用系统的区别。Android系统里init.rc中所启动的一个重要进程被称作zygote进程，也称为“种子进程”，从进程的角度来看，种子进程仅仅是一个Linux进程而已，它和一个只包含main()函数的C程序所产生的进程是同一个级别，但种子进程里面所运行的程序基本上就是Android内核的精华所在，其内部主要完成了两件事情。第一件事情是装载了一段程序代码，这些代码都是用C语言写的，这段代码的作用只是为了能够执行Java编译器编译出的字节码，功能类似Java虚拟机，在Android中称为Dalvik虚拟机。第二件事情必须基于第一件事情之后，即当Dalvik虚拟机代码初始化完成后，开始执行ZygoteInit.java类中的main()函数。ZygoteInit.java这个Jar包的目录位置信息也是在init.rc中进行配置的，是使用一个“zygote”标志符，Dalvik虚拟机就会从init.rc配置项的键值对中得到ZygoteInit类所在的Jar包，而这个Jar包正是Android的另一个核心–framework.jar。</p>
<p>接下ZygoteInit类中main()函数所做的事情和Linux本身就没多大关系了，该main()函数中才刚刚开始启动Android的核心功能。首先加载一些类文件，这些类将作为以后所有其它Apk程序共享的类，接着，会创建一个Socket服务端，该服务端将用于通过Socket启动新进程。zygote进程被称为“种子”进程的原因就是，当其内部的Socket服务端收到启动新的Apk进程的请求时，会使用Linux的一个系统调用folk()函数从自身复制出一个新的进程，新进程和Zygote进程将共享已经装载的类，这些类都是在framework.jar中定义的。</p>
</blockquote>
<pre><code>// ZygoteInit.java的main函数如下：  
public static void main(String argv[]) {  
    try {  
        …  
        registerZygoteSocket(); // 注册一个socket server来监听zygote命令  
        preloadClasses();//预加载java class  
        preloadResources();//预加载资源文件  
        …  
        gc();/*初始化GC垃圾回收机制*/  
        if (argv[1].equals(&quot;true&quot;)) {  

            /* 通过main中传递过来的第二个参数startsystemserver=”true” 启动systemserver, 在startSystemServer()中会fork一个新的进程命名为system_server， 执行的是com.android.server包中的SystemServer.java文件中的main函数*/  

            startSystemServer();
             ///*************  
        } else if(…)   
        …

        if (ZYGOTE_FORK_MODE) {  
             runForkMode();      /*将进入Zygote的子进程*/  
        } else {  
             runSelectLoopMode();/* Zygote进程进入无限循环，不再返回。接下来的zygote将会作为一个孵化服务进程来运行。*/  
        }  
        closeServerSocket();  
    }  
    …  
}  
</code></pre><p>简而言之：android程序进程创建的整个流程如下</p>
<ul>
<li>Application层的程序发起创建应用程序的命令；</li>
<li>Ams调度框架通过framework发起socket通讯通知新进程创建；</li>
<li>zygote孵化进程接收socket信息并调用内核创建新进程；</li>
</ul>
<p>也就是说 ，最终是通过zygote fork一个应用进程。</p>
<p>综上所述，创建程序新进程的任务最关键就是zygote进程。Zygote进程起到一个承上启下的作用。对于framework，zygote进程接收上层应用通过socket发送过来的新进程创建命令，对于kernel而言，zygote进程主要调用了内核的fork()系统调用来进行新进程的创建，所以zygote在android系统中扮演一个非常重要的角色，是新进程创建的一个孵化器。</p>
<p><img src="http://i.imgur.com/mDrhXtj.png" alt="process-flow"></p>
<p>Reference: </p>
<ul>
<li><a href="https://android.googlesource.com/" title="https://android.googlesource.com/" target="_blank" rel="external">Android 源码 repo</a></li>
<li><a href="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" title="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" target="_blank" rel="external">Android Anatomy and Physiology</a></li>
<li>柯元旦《android内核剖析》电子工业出版社</li>
</ul>
<h3 id="Activity启动"><a href="#Activity启动" class="headerlink" title="Activity启动"></a>Activity启动</h3><p>Android应用程序启动过程，即为LauncherActivity的启动过程，Android应用程序从Launcher启动 程序 流程如下所示：</p>
<pre><code>/***************************************************************** 
  * Launcher通过Binder告诉ActivityManagerService， 
  * 它将要启动一个新的Activity； 
  ****************************************************************/  
 Launcher.startActivitySafely-&gt;    
 Launcher.startActivity-&gt;

     //要求在新的Task中启动此Activity    
     //intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)    
     Activity.startActivity-&gt;    
     Activity.startActivityForResult-&gt;    
     Instrumentation.execStartActivity-&gt;    

     // ActivityManagerNative.getDefault()返回AMS Proxy接口    
     ActivityManagerNative.getDefault().startActivity-&gt;    
     ActivityManagerProxy.startActivity-&gt;    

        ActivityManagerService.startActivity-&gt; (AMS)    
        ActivityManagerService.startActivityAsUser-&gt;     

         ActivityStack.startActivityMayWait-&gt;    
        ActivityStack.resolveActivity(获取ActivityInfo)    
           //aInfo.name为main Activity,如：com.my.test.MainActivity    
           //aInfo.applicationInfo.packageName为包名，如com.my.test    
         ActivityStack.startActivityLocked-&gt;    
           //ProcessRecord callerApp; 调用者即Launcher信息    
           //ActivityRecord sourceRecord; Launcher Activity相关信息    
           //ActivityRecord r=new ActivityRecord(...)，将要创建的Activity相关信息      
         ActivityStack.startActivityUncheckedLocked-&gt;    
          //Activity启动方式：ActivityInfo.LAUNCH_MULTIPLE/LAUNCH_SINGLE_INSTANCE/    
          //             ActivityInfo.LAUNCH_SINGLE_TASK/LAUNCH_SINGLE_TOP)    
          // 创建一个新的task,即TaskRecord,并保存在ActivityRecord.task中    
          //r.setTask(new TaskRecord(mService.mCurTask, r.info, intent), null, true)    
          // 把新创建的Activity放在栈顶       
          ActivityStack.startActivityLocked-&gt;    
          ActivityStack.resumeTopActivityLocked-&gt;    
          ActivityStack.startPausingLocked (使Launcher进入Paused状态)-&gt;      

  /***************************************************************** 
   * AMS通过Binder通知Launcher进入Paused状态 
   ****************************************************************/  
   ApplicationThreadProxy.schedulePauseActivity-&gt;     
   //private class ApplicationThread extends ApplicationThreadNative    
   ApplicationThread.schedulePauseActivity-&gt;    

   ActivityThread.queueOrSendMessage-&gt;    

    // 调用Activity.onUserLeaveHint    
    // 调用Activity.onPause    
    // 通知activity manager我进入了pause状态    
    ActivityThread.handlePauseActivity-&gt;    

    /***************************************************************** 
     * Launcher通过Binder告诉AMS，它已经进入Paused状态 
     ****************************************************************/  
    ActivityManagerProxy.activityPaused-&gt;    
    ActivityManagerService.activityPaused-&gt;    
    ActivityStack.activityPaused-&gt;(把Activity状态修改为PAUSED)    
    ActivityStack.completePauseLocked-&gt;    

    // 参数为代表Launcher这个Activity的ActivityRecord    
    // 使用栈顶的Activity进入RESUME状态    
    ActivityStack.resumeTopActivityLokced-&gt;    
    //topRunningActivityLocked将刚创建的放于栈顶的activity取回来    
    // 即在ActivityStack.startActivityUncheckedLocked中创建的    

    /***************************************************************** 
     * AMS创建一个新的进程，用来启动一个ActivityThread实例， 
     * 即将要启动的Activity就是在这个ActivityThread实例中运行 
     ****************************************************************/  
    ActivityStack.startSpecificActivityLocked-&gt;    

     // 创建对应的ProcessRecord    
     ActivityManagerService.startProcessLocked-&gt;    

          // 启动一个新的进程    
          // 新的进程会导入android.app.ActivityThread类，并且执行它的main函数,    
          // 即实例化ActivityThread, 每个应用有且仅有一个ActivityThread实例    
          Process.start(&quot;android.app.ActivityThread&quot;,...)-&gt;    

          // 通过zygote机制创建一个新的进程    
          Process.startViaZygote-&gt;    

          // 这个函数在进程中创建一个ActivityThread实例，然后调用    
          // 它的attach函数，接着就进入消息循环    
          ActivityThread.main-&gt;    

      /***************************************************************** 
       * ActivityThread通过Binder将一个ApplicationThread类的Binder对象 
       * 传递给AMS，以便AMS通过此Binder对象来控制Activity整个生命周期 
       ****************************************************************/  
      ActivityThread.attach-&gt;    
      IActivityManager.attachApplication(mAppThread)-&gt;    
      ActivityManagerProxy.attachApplication-&gt;    
      ActivityManagerService.attachApplication-&gt;    

      // 把在ActivityManagerService.startProcessLocked中创建的ProcessRecord取出来    
      ActivityManagerService.attachApplicationLocked-&gt;    

      /***************************************************************** 
       * AMS通过Binder通知ActivityThread一切准备OK,它可以真正启动新的Activity了 
       ****************************************************************/              
      // 真正启动Activity    
      ActivityStack.realStartActivityLocked-&gt;    
      ApplicationThreadProxy.scheduleLaunchActivity-&gt;    
      ApplicationThread.scheduleLaunchActivity-&gt;    
      ActivityThread.handleLaunchActivity-&gt;    
        // 加载新的Activity类，并执行它的onCreate    
        ActivityThread.performLaunchActivity    
           /*---------------------------------------------
           1) Instrumentation.newActivity: 加载新类，即创建Activity对象；  
           2) ActivityClientRecord.packageInfo.makeApplication：创建Application对象；  
              &lt;LoadedApk.makeApplication&gt;  
           3) Activity.attach(Context context, ActivityThread aThread,  
                 Instrumentation instr, IBinder token, int ident,  
                 Application application, Intent intent, ActivityInfo info,  
                 CharSequence title, Activity parent, String id,  
                 NonConfigurationInstances lastNonConfigurationInstances,  
                 Configuration config)：把Application attach到Activity, 即把Activtiy  
                                        相关信息设置到新创建的Activity中  
           4) Instrumentation.callActivityOnCreate：调用onCreate；
            ---------------------------------------------*/    

        // 使用Activity进入RESUMED状态，并调用onResume    
        ActivityThread.handleResumeActivity    
</code></pre><p>从Activity的启动流程中，我们可以看到几个比较重要的类：</p>
<h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h4><p>顾名思义，仪器仪表，用于在应用程序中进行“测量”和“管理”工作。一个应用程序中只有一个Instrumentation实例对象，且每个Activity都有此对象的引用。Instrumentation将在任何应用程序运行前初始化，可以通过它监测系统与应用程序之间的所有交互，即类似于在系统与应用程序之间安装了个“窃听器”。</p>
<p>当ActivityThread 创建(callActivityOnCreate)、暂停、恢复某个Activity时，通过调用此对象的方法来实现，如：</p>
<p>1) 创建: callActivityOnCreate </p>
<p>2) 暂停: callActivityOnPause</p>
<p>3) 恢复: callActivityOnResume</p>
<h4 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h4><p>AMS提供的主要功能：</p>
<ul>
<li>统一调度各应用程序的Activities；</li>
<li>内存管理</li>
<li>进程管理</li>
</ul>
<h5 id="启动一个Activity的方式"><a href="#启动一个Activity的方式" class="headerlink" title="启动一个Activity的方式"></a>启动一个Activity的方式</h5><ul>
<li>在应用程序中调用startActivity()启动指定Activity；</li>
<li>在Launcher中点击一个应用程序的icon，启动新的Activity；</li>
<li>按“back”返回键，结束当前Activity，返回到上一个Activity；</li>
<li>长按“Home”键显示当前正在运行的程序列表，从中选择一个要启动的Activity；</li>
</ul>
<p>这四种方式最终都会按第一种方式进行Activity的启动，区别主要在于前端消息的接受和处理上不同。</p>
<h4 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h4><p>ActivityManagerService使用它来管理系统中所有的Activities的状态，Activities使用stack的方式进行管理。它是真正负责做事的家伙，很勤快的，但外界无人知道！</p>
<h4 id="TaskRecord类"><a href="#TaskRecord类" class="headerlink" title="TaskRecord类"></a>TaskRecord类</h4><p>ActivityManagerService中使用任务的概念来确保Activity启动和退出的顺序。TaskRecord中的几个重要变量如下：</p>
<pre><code>final int taskId;       // 每个任务的标识.
Intent intent;          // 创建该任务时对应的intent
int numActivities;   //该任务中的Activity数目
final ArrayList&lt;ActivityRecord&gt; mActivities = new ArrayList&lt;ActivityRecord&gt;();  //按照出现的先后顺序列出该任务中的所有Activity
</code></pre><h4 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a>ActivityRecord</h4><p>ActivityManagerService使用ActivityRecord数据类来保存每个Activity的信息，ActivityRecord类基于IApplicationToken.Stub类，也是一个Binder,所以可以被IPC调用。</p>
<p>主要包含的变量有：</p>
<ul>
<li><p>环境信息：Activity的工作环境，比如进程名称、文件路径、数据路径、图标、主题等，这些信息一般是固定的，比如以下变量：</p>
<pre><code>final String packageName; // the package implementing intent&apos;s component
final String processName; // process where this component wants to run
final String baseDir;   // where activity source (resources etc) located
final String resDir;   // where public activity source (public resources etc) located
final String dataDir;   // where activity data should go
int theme;              // resource identifier of activity&apos;s theme.
int realTheme;          // actual theme resource we will use, never 0.
</code></pre></li>
<li><p>运行状态数据信息：如idle、stop、finishing等，一般为boolean类型，如下</p>
<pre><code>boolean haveState;      // have we gotten the last activity state?
boolean stopped;        // is activity pause finished?
boolean delayedResume;  // not yet resumed because of stopped app switches?
boolean finishing;      // activity in pending finish list?
boolean configDestroy;  // need to destroy due to config change?
</code></pre></li>
</ul>
<h4 id="ProcessRecord—记录了一个进程的相关信息。"><a href="#ProcessRecord—记录了一个进程的相关信息。" class="headerlink" title="ProcessRecord—记录了一个进程的相关信息。"></a>ProcessRecord—记录了一个进程的相关信息。</h4><p>~\frameworks\base\services\java\com\android\server\am</p>
<p>一般情况下，一个应用程序（APK）运行会对应一个进程，而ProcessRecord就是用来记录一个进程的相关信息，主要包含以下几个方面：</p>
<ul>
<li><p>进程文件信息：与该进程对应的APK文件的内部信息，如：</p>
<pre><code>final ApplicationInfo info; // all about the first app in the process
final String processName;   // name of the process
final ArrayMap&lt;String, ProcessStats.ProcessState&gt; pkgList 
        = new ArrayMap&lt;String, ProcessStats.ProcessState&gt;();   //保存进程中所有APK文件包名
</code></pre></li>
<li><p>进程的内存状态信息：用于Linux系统的out of memory(OOM)情况的处理，当发生内存紧张时，Linux系统会根据进程的内存状态信息杀掉低优先级的进程，包括的变量有：</p>
<pre><code>int maxAdj;                 // Maximum OOM adjustment for this process
int curRawAdj;              // Current OOM unlimited adjustment for this process
int setRawAdj;              // Last set OOM unlimited adjustment for this process
int curAdj;                 // Current OOM adjustment for this process
int setAdj;                 // Last set OOM adjustment for this process
</code></pre><p> 变量中Adj的含义是调整值（adjustment）</p>
</li>
<li><p>进程中包含的Activity、ContentProvider、Service、Receiver等，如下</p>
<pre><code>final ArrayList&lt;ActivityRecord&gt; activities = new ArrayList&lt;ActivityRecord&gt;();
final ArraySet&lt;ServiceRecord&gt; services = new ArraySet&lt;ServiceRecord&gt;();
final ArraySet&lt;ServiceRecord&gt; executingServices = new ArraySet&lt;ServiceRecord&gt;();
final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;ConnectionRecord&gt;();
final ArraySet&lt;ReceiverList&gt; receivers = new ArraySet&lt;ReceiverList&gt;();
final ArrayMap&lt;String, ContentProviderRecord&gt; pubProviders = new ArrayMap&lt;String,             ContentProviderRecord&gt;();
final ArrayList&lt;ContentProviderConnection&gt; conProviders = new ArrayList&lt;ContentProviderConnection&gt;();
</code></pre></li>
</ul>
<h4 id="IApplicationThread接口AMS-gt-Application"><a href="#IApplicationThread接口AMS-gt-Application" class="headerlink" title="IApplicationThread接口AMS-&gt;Application"></a>IApplicationThread接口AMS-&gt;Application</h4><p>IApplicationThread为AMS作为客户端访问Application服务器端的Binder接口。当创建Application时，将把此Binder对象传递给AMS，然后AMS把它保存在mProcessNames.ProcessRecord.thread中。当需要通知Application工作时，则调用IApplicationThread中对应的接口函数。</p>
<p><img src="http://i.imgur.com/E67npgC.png" alt="IApplicationThread"></p>
<p>Reference:</p>
<p><a href="http://www.kancloud.cn/digest/androidframeworks/127785" title="http://www.kancloud.cn/digest/androidframeworks/127785" target="_blank" rel="external">http://www.kancloud.cn/digest/androidframeworks/127785</a></p>
<h4 id="关于Activity启动的流程图"><a href="#关于Activity启动的流程图" class="headerlink" title="关于Activity启动的流程图"></a>关于Activity启动的流程图</h4><p><img src="http://i.imgur.com/Vie24ZR.jpg" alt="launcher-flow"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/如何实现一个缓存系统/" itemprop="url">
                  如何实现一个缓存系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="如何实现一个缓存系统"><a href="#如何实现一个缓存系统" class="headerlink" title="如何实现一个缓存系统"></a>如何实现一个缓存系统</h2><p>试想这样一个场景，当你当你的而应用频繁要运用某一个组件的时候，而这个组件因动态原因都放置在网络或者disk上，这个时候必然会涉及性能的问题，碰到这类问题，我们自然而然的就会想到缓存，那么，我们该如何实现一个缓存系统，或者说是怎么从零开始设计一个缓存系统，接下来，就让我们一步步来见证一个缓存系统的实现。</p>
<h3 id="设计前准备工作"><a href="#设计前准备工作" class="headerlink" title="设计前准备工作"></a>设计前准备工作</h3><p>ok，这个时候我们脑通打开，高速旋转，做之前，我们要想明白这几件事情</p>
<ul>
<li>缓存到那个级别，即缓存到哪里？</li>
<li>如何访问缓存，即如何设计缓存API？</li>
</ul>
<p>带着这几个问题，让问题先转一下，缓存到什么地方，说白了，就是找个地来存储这些中间组件，而这些地方都有什么呢，常见的一般有内存、disk,设置网络（像云、网盘等）。</p>
<p>然后，我们知道要缓存到这些组件到上述说的这些地方上，那么缓存到这些地方上有什么好处呢？提高访问速度，对这个绝对是我们最想要的。</p>
<p>明白了上述，接下来就是如何缓存常用组件到内存、disk、网络上了。</p>
<h3 id="接口API实现"><a href="#接口API实现" class="headerlink" title="接口API实现"></a>接口API实现</h3><p>接下来，我们以实现 内存+disk双缓存设计为例来描述下如何去涉及一个缓存接口的API。</p>
<h4 id="第一步，抽象出一个需要缓存的组件实例"><a href="#第一步，抽象出一个需要缓存的组件实例" class="headerlink" title="第一步，抽象出一个需要缓存的组件实例"></a>第一步，抽象出一个需要缓存的组件实例</h4><pre><code>public Class ComponentBean{

    public void toString(){}
}
</code></pre><h4 id="第二步，设计内存缓存接口"><a href="#第二步，设计内存缓存接口" class="headerlink" title="第二步，设计内存缓存接口"></a>第二步，设计内存缓存接口</h4><p>内存中的缓存接口设计，首先我们想到的是Map,当然如果系统版本高于19，我们可以用ArrayMap,如果key值设计为Long,我们可以使用LongSparseArray.</p>
<ul>
<li>ArrayMap</li>
</ul>
<blockquote>
<p>ArrayMap is a generic key-&gt;value mapping data structure that is designed to be more memory efficient than a traditional HashMap. It keeps its mappings in an array data structure – an integer array of hash codes for each item, and an Object array of the key/value pairs.</p>
</blockquote>
<p>Added in API level 19</p>
<ul>
<li>LongSparseArray</li>
</ul>
<blockquote>
<p>SparseArray mapping longs to Objects. Unlike a normal array of Objects, there can be gaps in the indices. It is intended to be more memory efficient than using a HashMap to map Longs to Objects, both because it avoids auto-boxing keys and its data structure doesn’t rely on an extra entry object for each mapping.</p>
</blockquote>
<p>Added in API level 16</p>
<p>本次设计内存缓存，主要基于最常用的Map来设计。</p>
<pre><code>public interface IMemeoryCache{

    void put(String key, Reference&lt;ComponentBean&gt;value);

    ComponentBean get(String key);
}
</code></pre><p>上述是一个基本的设计，有存有取，那么接下来，要继续扩展一些基本的接口。试想 ，一个内存缓存系统除了存取之外，应该还有什么操作入口？remove?contain？是的，一个操作接口应该还包含一个删除入口、一个查询是否包含入口、一个能获取到当前缓存所有数据的入口、清空当前缓存数据的入口。</p>
<ul>
<li><p>删除入口</p>
<p>  删除，参照JDK Map设计，我们可以定义一下接口</p>
<pre><code>ComponentBean remove(String key);
</code></pre></li>
<li><p>查询是否包含入口</p>
<pre><code>boolean contain(String key);
</code></pre></li>
<li><p>获取到当前缓存所有数据的入口</p>
<p>  这个借口的实现，我们只要能获取到当前缓存中所有key值映射，就可以遍历当前缓存中所有数据了，所以</p>
<pre><code>Collection&lt;String&gt;keys();
</code></pre></li>
<li><p>清空当前缓存数据的入口</p>
<p>  void clear();</p>
</li>
</ul>
<p>最终设计下来，整体应该是：</p>
<pre><code>public interface IMemeoryCache{

    void put(String key, Reference&lt;ComponentBean&gt;value);

    ComponentBean get(String key);

    ComponentBean remove(String key);

    boolean contain(String key);

    Collection&lt;String&gt;keys();

    void clear();
}
</code></pre><p>当然，如果后续有需求，可以继续扩展 IMemeoryCache接口，骚年，拓展吧。</p>
<h4 id="第三步，设计Disk缓存接口"><a href="#第三步，设计Disk缓存接口" class="headerlink" title="第三步，设计Disk缓存接口"></a>第三步，设计Disk缓存接口</h4><p>Disk缓存，骚年们首先想到是什么呢？流操作？对象序列化？定义一个合理的缓存目录？反正，我先想到的是对象序列化，为什么，因为本次示例存储的就是一个对象嘛。</p>
<p>ok,接下来，我们先将我们要存储的对象序列化了</p>
<ul>
<li><p>存储的对象序列化</p>
<p>  package com.haio.uil;</p>
<p>  import android.os.Parcel;<br>  import android.os.Parcelable;</p>
<p>  public class ComponentBean implements Parcelable {</p>
<pre><code>private int componentId;

ComponentBean(Parcel in) {
    super();
    this.componentId = in.readInt();
}

@Override
public int describeContents() {
    return 0;
}

@Override
public void writeToParcel(Parcel paramParcel, int flag) {
    paramParcel.writeInt(componentId);
}

public static final Parcelable.Creator&lt;ComponentBean&gt; CREATOR = new Creator&lt;ComponentBean&gt;() {

    @Override
    public ComponentBean[] newArray(int size) {
        return new ComponentBean[size];
    }

    @Override
    public ComponentBean createFromParcel(Parcel paramParcel) {
        return new ComponentBean(paramParcel);
    }
};
</code></pre><p>  }</p>
</li>
</ul>
<p>在Android中使用序列化，无非两种途经： Parcelable 和 Serializable。</p>
<p>对象序列化的目的：</p>
<p>1）永久性保存对象，保存对象的字节序列到本地文件中；<br>2）通过序列化对象在网络中传递对象；<br>3）通过序列化在进程间传递对象。</p>
<p>要说明一点，本文主讲的对象 并非对象的序列化，所以如何序列化对象就不做重点阐述，但可以给出参考链接<br><a href="http://developer.android.com/intl/zh-cn/reference/android/os/Parcelable.html#PARCELABLE_WRITE_RETURN_VALUE" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/reference/android/os/Parcelable.html#PARCELABLE_WRITE_RETURN_VALUE</a></p>
<p><a href="http://www.developerphil.com/parcelable-vs-serializable/" target="_blank" rel="external">http://www.developerphil.com/parcelable-vs-serializable/</a></p>
<ul>
<li>Disk存储接口设计</li>
</ul>
<p>如Memorycache设计一样，我们先给出一个基本的入口，然后一次扩展</p>
<pre><code>public interface IDiskCache{

    File getDirectory();

    boolean save(String filename, ComponentBean bean) throws IOException;

    File get(String filename);
}
</code></pre><p>上述是一个基本的设计，有存有取，并且可以获取到当前存储的缓存目录，那么接下来，要继续扩展一些基本的接口。试想 ，一个Disk缓存系统除了存取之外，应该还有什么操作入口？remove?资源释放close？是的，disk cache操作接口应该还包含一个删除入口、清空当前缓存数据的入口、关闭流数据入口（毕竟设计IO操作）。</p>
<p>最终设计应该如下：</p>
<pre><code>public interface IDiskCache{

    File getDirectory();

    boolean save(String filename, ComponentBean bean) throws IOException;

    File get(String filename);

    boolean remove(String imageUri);

    void close();

    void clear();
}
</code></pre><p>重要的接口设计完了，接下来就是实现了，后续且听下回分解。</p>
<h2 id="缓存示例"><a href="#缓存示例" class="headerlink" title="缓存示例"></a>缓存示例</h2><p>###MemoryCache缓存</p>
<p>做一个memoryCache缓存系统，想想该如何设计，照之前的接口设计，我们通过Reference来缓存Object，这样并不能保证所缓存的对象一直存在，比如，通过WeakReference来缓存对象，当GCRoot可以遍历到时，就会回收。所以，如果设计缓存，我们在之前的基础上，加一个强引用缓存（有一定数目限制），这样就可以保证有一部分常用对象的重复利用。</p>
<p>重庆-zhusx(327270607)  11:43:52<br>如果你想序列化传递的话…整个对象的成员变量都得序列化<br>这个也就是为什么你之前这么写 会报错.<br>重庆-zhusx(327270607)  11:45:58<br>内部类 会把 外面一层的东西都包进去…也就是 所有对象必须序列话,而且外面一层的..的所有变量都序列化…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/android-anr分析/" itemprop="url">
                  Android ANR 分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T11:24:36+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>什么是ANR</li>
<li>ANR产生的原因</li>
<li>ANR流程分析</li>
<li>发生ANR如何定位</li>
<li>如何避免和解决ANR</li>
</ul>
<p>refer:<a href="http://developer.android.com/intl/zh-cn/training/articles/perf-anr.html#anr" title="keeping your app response" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/training/articles/perf-anr.html#anr</a></p>
<p><strong>1.什么是ANR</strong></p>
<ul>
<li>ANR:Application Not Responding，即应用无响应</li>
<li>为用户在主线程长时间被阻塞是提供交互，提高用户体验；</li>
<li>android系统自身的一种检测机制</li>
</ul>
<p><strong>1.1 ANR的类型</strong></p>
<p>ANR一般有三种类型：</p>
<ol>
<li><p>KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应</p>
</li>
<li><p>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成</p>
</li>
<li><p>ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成</p>
</li>
</ol>
<blockquote>
<ul>
<li>No response to an input event (such as key press or screen touch events) within 5 seconds.</li>
<li>A BroadcastReceiver hasn’t finished executing within 10 seconds.</li>
</ul>
</blockquote>
<p><strong>1.1.1 KeyDispatchTimeout</strong></p>
<p>Akey or touch event was not dispatched within the specified time（按键或触摸事件在特定时间内无响应）</p>
<p>具体的超时时间的定义在framework下的ActivityManagerService.java</p>
<p>//How long we wait until we timeout on key dispatching.</p>
<p>staticfinal int KEY_DISPATCHING_TIMEOUT = 5*1000</p>
<p><strong>2.ANR产生的原因</strong></p>
<p>超时时间的计数一般是从按键分发给app开始。超时的原因一般有两种：</p>
<p>(1)当前的事件没有机会得到处理（即UI线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）</p>
<p>(2)当前的事件正在处理，但没有及时完成</p>
<p>(3)需要满足的条件：</p>
<ul>
<li>主线程：只有应用的主线程响应超时才会导致ANR</li>
<li>超时时间（Timeout）:导致ANR的原因不同，系统限定的时间也不同，但只要超过时间上闲，系统就会发出Signal 3，产生ANR</li>
<li>输入操作/特定操作：输入操作指按键、触屏等操作，特定操作指广播、服务中执行耗时方法等。</li>
</ul>
<p><strong>summary：</strong></p>
<p>引起ANR的根本原因总的来说如下：</p>
<ul>
<li><p>应用程序自身引起的</p>
<p>  例如，主线程阻塞（block）、挂起、死锁、死循环、执行耗时操作等</p>
</li>
<li><p>其他应用进程引起的</p>
<p>  例如，其他进程的CPU占用率过高、某一时刻系统CPU负载过高等，都会导致当前进程无法抢到CPU时间片。</p>
</li>
<li><p>IO wait</p>
<p>  文件读写耗时较久，占用CPU时间片较长，导致ANR</p>
</li>
</ul>
<p>提示：如果你在解决其他问题时也需要查看Java进程中各个线程的函数堆栈信息，就可以使用向目标进程发送SIGNAL_QUIT（3）这个技巧。其实这个名称有点误导，它并不会让进程真正退出。<br><strong><br>3.ANR出现流程分析</strong></p>
<ul>
<li><p>输入时间响应超时导致ANR流程</p>
<p>  在系统输入管理服务进程（InputManagerService）中有一个线程（InputDispathcerThread）专门管理输入事件的分发，在该线程处理输入事件的过程中，回调用InputDispatcher对象方法不断的检测处理过程是否超时，一旦超时，则会通过一些列的回调调用InputMethod对象的notifyANR方法，其会最终出发AMS中handler对象的SHOW_NOT_RESPONDING_MSG这个事件，显示ANR对话框。</p>
</li>
<li><p>广播发生ANR流程</p>
<p>  广播分为三类：普通的，有序的，异步的。只有有序（ordered）的广播才会发生超时，而在AndroidManifest中注册的广播都会被当做有序广播来处理，会被放在广播的队列中串行处理。AMS在处理广播队列时，会设置一个超时时间，当处理一个广播达到超时时间的限制时，就会触发BroadcastQueue类对象的processNextBroadcast方法来判断是否超时，如果超时，就会终止该广播，触发ANR对话框。</p>
</li>
<li><p>UI线程</p>
<p>  UI线程主要包括如下：</p>
<ul>
<li>Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick(),etc声明周期方法里</li>
</ul>
<ol>
<li><p>AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel,etc这些异步更改UI界面的方法里</p>
</li>
<li><p>Mainthread handler: handleMessage(), post*(runnable r), getMainLooper(),etc通过handler发送消息到主线程的looper,即占用主线程looper的</p>
</li>
</ol>
</li>
</ul>
<p><strong>4.发生ANR如何定位</strong></p>
<p>系统发生ANR的时候，一般会以以下三种方式记录</p>
<ul>
<li>logcat日志；</li>
<li>/data/anr/traces.txt</li>
<li>dropBox服务；</li>
</ul>
<p><strong>4.1 通过logcat文件分析</strong></p>
<p>logcat文件：</p>
<pre><code>04-01 13:12:11.572 I/InputDispatcher( 220): Application is not responding:Window{2b263310com.android.email/com.android.email.activity.SplitScreenActivitypaused=false}.
5009.8ms since event, 5009.5ms since waitstarted
04-0113:12:11.572 I/WindowManager( 220): Input event 
dispatching timedout sending 
tocom.android.email/com.android.email.activity.SplitScreenActivity

04-01 13:12:14.123 I/Process( 220): Sending signal. PID: 21404 SIG: 3---发生ANR的时间和生成trace.txt的时间
04-01 13:12:14.123 I/dalvikvm(21404):threadid=4: reacting to 
signal 3 
……
04-0113:12:15.872 E/ActivityManager( 220): ANR in 
com.android.email(com.android.email/.activity.SplitScreenActivity)
04-0113:12:15.872 E/ActivityManager( 220): 
Reason:keyDispatchingTimedOut  -----ANR的类型
04-0113:12:15.872 E/ActivityManager( 220): Load: 8.68 / 8.37 / 8.53 --CPU的负载情况
04-0113:12:15.872 E/ActivityManager( 220): CPUusage from 4361ms to 699ms ago ----CPU在ANR发生前的使用情况

04-0113:12:15.872 E/ActivityManager( 220): 5.5%21404/com.android.email: 1.3% user + 4.1% kernel / faults:
10 minor
04-0113:12:15.872 E/ActivityManager( 220): 4.3%220/system_server: 2.7% user + 1.5% kernel / faults: 11
minor 2 major
04-0113:12:15.872 E/ActivityManager( 220): 0.9%52/spi_qsd.0: 0% user + 0.9% kernel
04-0113:12:15.872 E/ActivityManager( 220): 0.5%65/irq/170-cyttsp-: 0% user + 0.5% kernel
04-0113:12:15.872 E/ActivityManager( 220): 0.5%296/com.android.systemui: 0.5% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 100%TOTAL: 4.8% user + 7.6% kernel + 87% iowait
04-0113:12:15.872 E/ActivityManager( 220): CPUusage from 3697ms to 4223ms later:-- ANR后CPU的使用量
04-0113:12:15.872 E/ActivityManager( 220): 25%21404/com.android.email: 25% user + 0% kernel / faults: 191 minor
04-0113:12:15.872 E/ActivityManager( 220): 16% 21603/__eas(par.hakan: 16% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 7.2% 21406/GC: 7.2% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 1.8% 21409/Compiler: 1.8% user + 0% kernel
04-0113:12:15.872 E/ActivityManager( 220): 5.5%220/system_server: 0% user + 5.5% kernel / faults: 1 minor
04-0113:12:15.872 E/ActivityManager( 220): 5.5% 263/InputDispatcher: 0% user + 5.5% kernel
04-0113:12:15.872 E/ActivityManager( 220): 32%TOTAL: 28% user + 3.7% kernel
</code></pre><p>从LOG可以看出：</p>
<ul>
<li><p>ANR的类型</p>
<p>  上面的日志课可以看出anr的类型为keyDispatchingTimedOut</p>
</li>
<li><p>CPU的使用情况<br>  CPU的使用情况包括发生ANR之前CPU的负载情况<br>  如果CPU使用量接近100%，说明当前设备很忙，有可能是CPU饥饿导致了ANR<br>  从上面看出 total CPU达到100%,并且 io wait占到87%,所以 说明在主线程进行io操作。</p>
</li>
</ul>
<p>如果CPU使用量很少，说明主线程被BLOCK了</p>
<p>如果IOwait很高，说明ANR有可能是主线程在进行I/O操作造成的</p>
<ul>
<li><p>Thread的状态</p>
<p>  ThreadState (defined at “dalvik/vm/thread.h “)<br>  THREAD_UNDEFINED = -1, /<em> makes enum compatible with int32_t </em>/<br>  THREAD_ZOMBIE = 0, /<em> TERMINATED </em>/<br>  THREAD_RUNNING = 1, /<em> RUNNABLE or running now </em>/<br>  THREAD_TIMED_WAIT = 2, /<em> TIMED_WAITING in Object.wait() </em>/<br>  THREAD_MONITOR = 3, /<em> BLOCKED on a monitor </em>/<br>  THREAD_WAIT = 4, /<em> WAITING in Object.wait() </em>/<br>  THREAD_INITIALIZING= 5, /<em> allocated, not yet running </em>/<br>  THREAD_STARTING = 6, /<em> started, not yet on thread list </em>/<br>  THREAD_NATIVE = 7, /<em> off in a JNI native method </em>/<br>  THREAD_VMWAIT = 8, /<em> waiting on a VM resource </em>/<br>  THREAD_SUSPENDED = 9, /<em> suspended, usually by GC or debugger </em>/  </p>
</li>
</ul>
<p>Thread.java中定义的状态 &nbsp;&nbsp; &nbsp;Thread.cpp中定义的状态&nbsp;&nbsp; &nbsp;说明</p>
<p>TERMINATED&nbsp;&nbsp; &nbsp;ZOMBIE&nbsp;&nbsp; &nbsp;线程死亡，终止运行</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;RUNNING/RUNNABLE&nbsp;&nbsp; &nbsp;线程可运行或正在运行</p>
<p>TIMED_WAITING&nbsp;&nbsp; &nbsp;TIMED_WAIT&nbsp;&nbsp; &nbsp;执行了带有超时参数的wait、sleep或join函数</p>
<p>BLOCKED&nbsp;&nbsp; &nbsp;MONITOR&nbsp;&nbsp; &nbsp;线程阻塞，等待获取对象锁</p>
<p>WAITING&nbsp;&nbsp; &nbsp;WAIT&nbsp;&nbsp; &nbsp;执行了无超时参数的wait函数</p>
<p>NEW&nbsp;&nbsp; &nbsp;INITIALIZING&nbsp;&nbsp; &nbsp;新建，正在初始化，为其分配资源</p>
<p>NEW&nbsp;&nbsp; &nbsp;STARTING&nbsp;&nbsp; &nbsp;新建，正在启动</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;NATIVE&nbsp;&nbsp; &nbsp;正在执行JNI本地函数</p>
<p>WAITING&nbsp;&nbsp; &nbsp;VMWAIT&nbsp;&nbsp; &nbsp;正在等待VM资源</p>
<p>RUNNABLE&nbsp;&nbsp; &nbsp;SUSPENDED&nbsp;&nbsp; &nbsp;线程暂停，通常是由于GC或debug被暂停</p>
<p>?&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;UNKNOWN&nbsp;&nbsp; &nbsp;未知状态</p>
<p>traces.txt文件</p>
<pre><code>DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 VMWAIT
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=9437 nice=0 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=2 stm=1 core=0
  #00  pc 0000dca0  /system/lib/libc.so (__futex_syscall3+8)
  #01  pc 000121cc  /system/lib/libc.so
  #02  pc 00053aff  /system/lib/libdvm.so (dvmLockThreadList(Thread*)+38)
  #03  pc 0005427b  /system/lib/libdvm.so (dvmCreateInternalThread(long*, char const*, void* (*)(void*), void*)+134)
  #04  pc 00047427  /system/lib/libdvm.so (dvmInitAfterZygote()+274)
  #05  pc 0006580b  /system/lib/libdvm.so
  #06  pc 0006592b  /system/lib/libdvm.so
  #07  pc 00029020  /system/lib/libdvm.so
  #08  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #09  pc 0005fed5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
  #10  pc 0004aee7  /system/lib/libdvm.so
  #11  pc 00048c75  /system/lib/libandroid_runtime.so
  #12  pc 00049691  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const*, char const*)+368)
  #13  pc 00000dcf  /system/bin/app_process
  #14  pc 00017193  /system/lib/libc.so (__libc_init+38)
  #15  pc 00000b34  /system/bin/app_process
  at dalvik.system.Zygote.nativeForkAndSpecialize(Native Method)
  at dalvik.system.Zygote.forkAndSpecialize(Zygote.java:117)
  at com.android.internal.os.ZygoteConnection.runOnce(ZygoteConnection.java:231)
  at com.android.internal.os.ZygoteInit.runSelectLoopMode(ZygoteInit.java:669)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:566)
  at dalvik.system.NativeStart.main(Native Method)
</code></pre><p>logcat文件：</p>
<pre><code>11-05 13:31:39.511 E/ActivityManager(  498): ANR in com.boyaa.engineddz.main

11-05 13:31:39.511 E/ActivityManager(  498): Reason: Executing service com.boyaa.engineddz.main/com.boyaa.boyaaad.service.FloatWindowService

11-05 13:31:39.511 E/ActivityManager(  498): Load: 1.94 / 1.33 / 0.67

11-05 13:31:39.511 E/ActivityManager(  498): CPU usage from 9953ms to 0ms ago:

11-05 13:31:39.511 E/ActivityManager(  498):   32% 11780/com.boyaa.engineddz.main: 30% user + 2.3% kernel / faults: 125 minor

11-05 13:31:39.511 E/ActivityManager(  498):   9.3% 166/surfaceflinger: 3.8% user + 5.5% kernel / faults: 1250 minor

11-05 13:31:39.511 E/ActivityManager(  498):   3.3% 11818/com.boyaa.engineddz.main: 0% user + 3.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.4% 11817/com.boyaa.engineddz.main: 0.4% user + 2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 1.9% user + 0.4% kernel / faults: 71 minor

11-05 13:31:39.511 E/ActivityManager(  498):   2.2% 498/system_server: 1.2% user + 1% kernel / faults: 46 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.7% 11523/com.boyaa.engineddz.main:pushservice: 0% user + 0.7% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.7% 11549/com.boyaa.engineddz.main:dservice_v1: 0.4% user + 0.3% kernel / faults: 182 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.6% 11799/com.boyaa.engineddz.main: 0.4% user + 0.2% kernel / faults: 524 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 126/ueventd: 0% user + 0.5% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 163/netd: 0.2% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.5% 11507/com.boyaa.engineddz.main:dservice_v1: 0.2% user + 0.3% kernel / faults: 2 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0.4% 159/vold: 0.1% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.3% 6070/kworker/0:5: 0% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.3% 10092/kworker/u:2: 0% user + 0.3% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 262/adbd: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 9849/kworker/0:0: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 10291/kworker/u:3: 0% user + 0.2% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.2% 11559/com.boyaa.engineddz.main:pushservice: 0% user + 0.2% kernel / faults: 210 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0% 110/file-storage: 0% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 251/sdcard: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 522/flush-179:0: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0% 1212/com.tencent.mobileqq:MSF: 0% user + 0% kernel / faults: 6 minor

11-05 13:31:39.511 E/ActivityManager(  498):   0% 9022/com.boyaa.engineddz.main: 0% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 10309/kworker/2:2: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 11753/kworker/3:2: 0.1% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   0.1% 11758/logcat: 0% user + 0.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 22% TOTAL: 10% user + 4.5% kernel + 7.5% iowait

11-05 13:31:39.511 E/ActivityManager(  498): CPU usage from 2161ms to 2685ms later:

11-05 13:31:39.511 E/ActivityManager(  498):   45% 11780/com.boyaa.engineddz.main: 43% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 43% 11831/Thread-555: 41% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   9.2% 498/system_server: 3.7% user + 5.5% kernel / faults: 16 minor

11-05 13:31:39.511 E/ActivityManager(  498): 7.4% 515/ActivityManager: 1.8% user + 5.5% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 507/FinalizerDaemon: 1.8% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 642/UEventObserver: 1.8% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   7.4% 166/surfaceflinger: 5.5% user + 1.8% kernel / faults: 66 minor

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 452/SurfaceFlinger: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 463/SurfaceFlinger: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.8% 464/EventThread: 0% user + 1.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 1.1% user + 1.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 2.3% 737/ndroid.systemui: 1.1% user + 1.1% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   2.8% 11817/com.boyaa.engineddz.main: 0% user + 2.8% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11817/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11819/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   1.4% 11799/com.boyaa.engineddz.main: 1.4% user + 0% kernel / faults: 53 minor

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11800/.engineddz.main: 1.4% user + 0% kernel

11-05 13:31:39.511 E/ActivityManager(  498):   1.4% 11818/com.boyaa.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11818/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 1.4% 11820/.engineddz.main: 0% user + 1.4% kernel

11-05 13:31:39.511 E/ActivityManager(  498): 28% TOTAL: 14% user + 4.3% kernel + 9.5% iowai
</code></pre><p>traces.txt文件：</p>
<pre><code>----- pid 498 at 2015-11-05 13:32:52 -----
Cmd line: system_server

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 NATIVE
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=498 nice=0 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=669 stm=136 core=1
  #00  pc 0000cb90  /system/lib/libc.so (__ioctl+8)
  #01  pc 00027fed  /system/lib/libc.so (ioctl+16)
  #02  pc 00016f61  /system/lib/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+124)
  #03  pc 00017653  /system/lib/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+154)
  #04  pc 000011d9  /system/lib/libsystem_server.so (system_init+312)
  #05  pc 0001fb70  /system/lib/libdvm.so (dvmPlatformInvoke+112)
  #06  pc 0004e8b9  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+360)
  #07  pc 00029020  /system/lib/libdvm.so
  #08  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #09  pc 0006017f  /system/lib/libdvm.so (dvmInvokeMethod(Object*, Method const*, ArrayObject*, ArrayObject*, ClassObject*, bool)+374)
  #10  pc 00067125  /system/lib/libdvm.so
  #11  pc 00029020  /system/lib/libdvm.so
  #12  pc 0002d7e8  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
  #13  pc 0005fed5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
  #14  pc 0004aee7  /system/lib/libdvm.so
  #15  pc 00048c75  /system/lib/libandroid_runtime.so
  #16  pc 00049691  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const*, char const*)+368)
  #17  pc 00000dcf  /system/bin/app_process
  #18  pc 00017193  /system/lib/libc.so (__libc_init+38)
  #19  pc 00000b34  /system/bin/app_process
  at com.android.server.SystemServer.init1(Native Method)
  at com.android.server.SystemServer.main(SystemServer.java:983)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:804)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:571)
  at dalvik.system.NativeStart.main(Native Method)

提示正在执行JNI层函数，导致这一步极有可能就是native层内存不够了，就要通过dumpsys meminfo 来查看下
</code></pre><p>logcat文件：</p>
<pre><code>11-05 15:32:55.465 E/ActivityManager(  498): ANR in com.boyaa.engineddz.main

11-05 15:32:55.465 E/ActivityManager(  498): Reason: Broadcast of Intent { act=com.igexin.sdk.action.lKooQgpZeM7hxbzRkb34f4 flg=0x10 cmp=com.boyaa.engineddz.main/com.boyaa.godsdk.core.GetuiReceiver (has extras) }

11-05 15:32:55.465 E/ActivityManager(  498): Load: 0.42 / 0.27 / 0.25

11-05 15:32:55.465 E/ActivityManager(  498): CPU usage from 6489ms to 25ms ago:

11-05 15:32:55.465 E/ActivityManager(  498):   4.6% 16150/com.boyaa.engineddz.main: 0.3% user + 4.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   4.4% 16149/com.boyaa.engineddz.main: 0.1% user + 4.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.6% 498/system_server: 1.3% user + 1.2% kernel / faults: 61 minor

11-05 15:32:55.465 E/ActivityManager(  498):   2% 16107/com.boyaa.engineddz.main: 0.3% user + 1.7% kernel / faults: 4 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.7% 16126/com.boyaa.engineddz.main: 0.4% user + 1.2% kernel / faults: 264 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.5% 737/com.android.systemui: 1% user + 0.4% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1% 16221/com.boyaa.engineddz.main:pushservice: 0.4% user + 0.6% kernel / faults: 151 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.9% 16173/com.boyaa.engineddz.main:dservice_v1: 0% user + 0.9% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.9% 16188/com.boyaa.engineddz.main:pushservice: 0.4% user + 0.4% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 166/surfaceflinger: 0.1% user + 0.6% kernel / faults: 75 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 14398/kworker/0:0: 0% user + 0.7% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.7% 16212/com.boyaa.engineddz.main:dservice_v1: 0.3% user + 0.4% kernel / faults: 112 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 248/sensors.qcom: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 262/adbd: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.3% 16197/kworker/0:2: 0% user + 0.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 159/vold: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 163/netd: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 709/MC_Thread: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 719/wpa_supplicant: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 8772/com.boyaa.engineddz.main: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 9486/com.boyaa.engineddz.main: 0% user + 0% kernel / faults: 1 minor

11-05 15:32:55.465 E/ActivityManager(  498):   0% 15494/kworker/0:1: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 15928/kworker/3:0: 0% user + 0.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0% 15930/kworker/1:0: 0% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 15934/kworker/u:2: 0% user + 0.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   0.1% 16104/logcat: 0.1% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498): 5.6% TOTAL: 1.1% user + 4% kernel + 0.4% iowait

11-05 15:32:55.465 E/ActivityManager(  498): CPU usage from 2311ms to 2839ms later:

11-05 15:32:55.465 E/ActivityManager(  498):   12% 498/system_server: 5.5% user + 7.4% kernel / faults: 36 minor

11-05 15:32:55.465 E/ActivityManager(  498):     7.4% 515/ActivityManager: 1.8% user + 5.5% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     3.7% 507/FinalizerDaemon: 3.7% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 689/WifiStateMachin: 1.8% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 12027/Binder_D: 1.8% user + 0% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.3% 262/adbd: 0% user + 2.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     2.3% 262/adbd: 0% user + 2.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   2.3% 737/com.android.systemui: 2.3% user + 0% kernel / faults: 2 minor

11-05 15:32:55.465 E/ActivityManager(  498):     2.3% 737/ndroid.systemui: 1.1% user + 1.1% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   3.6% 16149/com.boyaa.engineddz.main: 0% user + 3.6% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     3.6% 16149/.engineddz.main: 0% user + 3.6% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16156/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.3% 15494/kworker/0:1: 0% user + 1.3% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.4% 16126/com.boyaa.engineddz.main: 0% user + 1.4% kernel / faults: 43 minor

11-05 15:32:55.465 E/ActivityManager(  498):   1.8% 16150/com.boyaa.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16150/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):     1.8% 16152/.engineddz.main: 0% user + 1.8% kernel

11-05 15:32:55.465 E/ActivityManager(  498):   1.4% 16212/com.boyaa.engineddz.main:dservice_v1: 0% user + 1.4% kernel / faults: 18 minor

11-05 15:32:55.465 E/ActivityManager(  498): 9% TOTAL: 3.3% user + 5.6% kernel
</code></pre><p>traces.txt文件</p>
<pre><code>----- pid 16107 at 2015-11-05 15:32:52 -----
Cmd line: com.boyaa.engineddz.main

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 MONITOR
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41937700 self=0x400bc0b0
  | sysTid=16107 nice=-15 sched=0/0 cgrp=apps handle=1074757424
  | schedstat=( 0 0 0 ) utm=475 stm=38 core=3
  at java.lang.ProcessManager.exec(ProcessManager.java:~206)
  - waiting to lock &lt;0x4252a508&gt; (a java.util.HashMap) held by tid=14 (Thread-815)
  at java.lang.ProcessBuilder.start(ProcessBuilder.java:195)
  at com.tencent.stat.common.l.b((null):-1)
  at com.tencent.stat.common.k.z((null):-1)
  at com.tencent.stat.common.c.&lt;init&gt;((null):-1)
  at com.tencent.stat.common.c.&lt;init&gt;((null):-1)
  at com.tencent.stat.common.a.a((null):-1)
  at com.tencent.stat.common.a.&lt;init&gt;((null):-1)
  at com.tencent.stat.a.k.&lt;init&gt;((null):-1)
  at com.tencent.stat.StatService.d((null):-1)
  at com.tencent.stat.StatService.a((null):-1)
  at com.tencent.stat.StatService.startStatService((null):-1)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.tencent.connect.a.a.c(ProGuard:90)
  at com.tencent.connect.auth.QQAuth.&lt;init&gt;(ProGuard:43)
  at com.tencent.connect.auth.QQAuth.createInstance(ProGuard:78)
  at com.tencent.tauth.Tencent.&lt;init&gt;(ProGuard:49)
  at com.tencent.tauth.Tencent.createInstance(ProGuard:57)
  at com.boyaa.godsdk.core.QQShareSDK.initSDK(QQShareSDK.java:149)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.boyaa.godsdk.core.utils.ReflectUtils.invokeMethod(ReflectUtils.java:-1)
  at com.boyaa.godsdk.core.GodSDK.invokeInitPlugin(GodSDK.java:-1)
  at com.boyaa.godsdk.core.GodSDK.access$8(GodSDK.java:-1)
  at com.boyaa.godsdk.core.GodSDK$5.handleMessage(GodSDK.java:-1)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loop(Looper.java:137)
  at android.app.ActivityThread.main(ActivityThread.java:4881)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:511)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:804)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:571)
  at dalvik.system.NativeStart.main(Native Method)

死锁导致 anr，可以最终朔源，看看是有谁持有锁，发现是tid=14的线程持有锁，那么就要分析tid=14的线程函数栈，发现时沃商店在执行shell脚本的时候 导致死锁了。
</code></pre><p>如何避免和解决ANR</p>
<p>1&gt;：UI线程尽量只做跟UI相关的工作</p>
<p>2&gt;：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3&gt;：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<p>4&gt;：是在绕不开主线程，可以尝试通过Handler延迟加载</p>
<p>5&gt;.广播中如果有耗时操作，建议放在service中去执行，或者通过handlerThread分发执行。</p>
<p>6&gt;.分析着重点：</p>
<ul>
<li>cpu占用率方面<ul>
<li>可以通过分析各进程的CPU时间占用率，来判断是否为某些进程长期占用CPU导致该进程无法获取到足够的CPU处理时间，而导致ANR</li>
<li>重点关注下CPU的负载，即logcat中Load1(Load: 0.42 / 0.27 / 0.25，即cpu平均负载)，各个进程总的CPU时间占用率，用户CPU时间占用率，核心态CPU时间占用率，以及iowait CPU时间占用率。</li>
</ul>
</li>
<li>内存方面<ul>
<li>主要看当前应用native和dalvik层内存使用情况</li>
<li>结合系统给每个应用分配的最大内存来分析</li>
</ul>
</li>
</ul>
<p>附：cpu 负载</p>
<p>CPU负载/平均负载</p>
<blockquote>
<p>CPU负载是指某一时刻系统中运行队列长度之和加上当前正在CPU上运行的进程数，而CPU平均负载可以理解为一段时间内正在使用和等待使用CPU的活动进程的平均数量。在Linux中“活动进程”是指当前状态为运行或不可中断阻塞的进程。通常所说的负载其实就是指平均负载。<br>用一个从网上看到的很生动的例子来说明（不考虑CPU时间片的限制），把设备中的一个单核CPU比作一个电话亭，把进程比作正在使用和等待使用电话的人，假如有一个人正在打电话，有三个人在排队等待，此刻电话亭的负载就是4。使用中会不断的有人打完电话离开，也会不断的有其他人排队等待，为了得到一个有参考价值的负载值，可以规定每隔5秒记录一下电话亭的负载，并将某一时刻之前的一分钟、五分钟、十五分钟的的负载情况分别求平均值，最终就得到了三个时段的平均负载。<br>实际上我们通常关心的就是在某一时刻的前一分钟、五分钟、十五分钟的CPU平均负载，例如以上日志中这三个值分别是3.85、3.41、3.16，说明前一分钟内正在使用和等待使用CPU的活动进程平均有3.85个，依此类推。在大型服务器端应用中主要关注的是第五分钟和第十五分钟的两个值，但是Android主要应用在便携手持设备中，有特殊的软硬件环境和应用场景，短时间内的系统的较高负载就有可能造成ANR，所以笔者认为一分钟内的平均负载相对来说更具有参考价值。<br>CPU的负载和使用率没有必然关系，有可能只有一个进程在使用CPU，但执行的是复杂的操作；也有可能等待和正在使用CPU的进程很多，但每个进程执行的都是简单操作。<br>实际处理问题时偶尔会遇到由于平均负载高引起的ANR，典型的特征就是系统中应用进程数量多，CPU总使用率较高，但是每个进程的CPU使用率不高，当前应用进程主线程没有异常阻塞，一分钟内的CPU平均负载较高。</p>
</blockquote>
<p>5.本次我爱 主要做的工作：</p>
<p>1）数据测量，以及命令使用</p>
<ul>
<li>通过应用性能工具（traceView/systemTrace(android高版本支持)）等分析各个方法占用时间，为分析打好依据；</li>
<li>通过 adb shell am start -W -n package/activity来测试记录app的启动时间；</li>
<li>通过查看/proc/stat 、 /proc/pid/stat来得到cpu占用率相关信息</li>
<li>通过查看/proc/meminfo、dumpsys meminfo、dumpsys meminfo package|pid来确认单个应用的内存使用情况（此步骤包括采用Heap分析工具分析）</li>
</ul>
<p>2）优化版本</p>
<ul>
<li>第一版本：godsdk全部异步Looper执行</li>
<li>第二版本：分两步，1.解析配置文件异步；2.各个sdk初始化整体在UI中执行</li>
<li>第三版本：分三步，1.解析配置文件异步；2.sdk初始化在UI中执行；3.一次将sdk的初始化post到主线程中；</li>
<li>第四版本：分三步，1.解析配置文件异步；2.各个sdk初始化整体在UI中执行；3.优化具体sdk中的封装；</li>
</ul>
<p>3）修改依据</p>
<ul>
<li>通过分析traceView 文件按照初始化占用时间由长到短列出表格，然后一次采用第三方demo测试确认是否可以异步执行；</li>
<li>分开依次post到主线程 和 同时一起放到主线程，关于上一步数据发现分开和一起其实差别不大，因为导致时间占用较长主要就是那几个sdk导致的，而大多数sdk的初始化占用时间很少，另外，分开post反而会占用更多的资源，导致ANR或者初始化时间更长。</li>
<li>延迟加载</li>
<li>传入数据给客户端，这一步做了两部小改动<ul>
<li>对于那些只有在初始化后才能获取pmode的sdk，做了编译前pmode动态写入操作，即在打包过程中，就把用户动态写入的pmode或者数据写入smali文件中，这样在初始化的时候就避免只有初始化成功后才能获取的情况；</li>
<li>获取pmode不一定要等到初始化成功去获取，只要等到各个sdk对象new成功后就可以获取（提前了，较之前对于异步获取godsdk提供的数据有时候获取不到的情况有所改善）</li>
</ul>
</li>
</ul>
<p>4）整体来说，修改ANR，关键之处就在于各个sdk里的处理了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="haiolv" />
          <p class="site-author-name" itemprop="name">haiolv</p>
          <p class="site-description motion-element" itemprop="description">Just do it</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/haiolv" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://developer.android.com/" target="_blank" title="Android 官网">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Android 官网
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://cstsinghua.github.io/" title="Atypical programmer" target="_blank">Atypical programmer</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hellokugo.github.io/" title="Hellokugo" target="_blank">Hellokugo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://aso210.github.io/" title="Aso210" target="_blank">Aso210</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haiolv</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
